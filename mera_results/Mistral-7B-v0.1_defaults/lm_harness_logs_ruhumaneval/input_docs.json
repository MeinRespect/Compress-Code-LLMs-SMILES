{
    "61": {
        "instruction": "Реализуй функцию(ии) на языке Python\n{function}",
        "inputs": {
            "function": "from typing import List\n\n\ndef missing_number(array: List[int]) -> int:\n    \"\"\"Дан массив чисел array, который включает в себя все целые числа отрезка от нуля до количества чисел в массиве, кроме одного числа. Выведите число, которое пропущено. Гарантируется, что в массиве более одного элемента.\n    Примеры:\n       missing_number(array=[7, 3, 5, 1, 0, 2, 6]) == 4\n       missing_number(array=[5, 7, 1, 10, 6, 2, 8, 0, 9, 4]) == 3\n    \"\"\"",
            "tests": "[{'array': [7, 3, 5, 1, 0, 2, 6]}, {'array': [5, 7, 1, 10, 6, 2, 8, 0, 9, 4]}, {'array': [6, 1, 5, 0, 4, 3]}, {'array': [0, 7, 3, 2, 8, 4, 10, 9, 1, 6, 11]}, {'array': [1, 3, 8, 7, 4, 0, 2, 6, 5, 9]}, {'array': [8, 3, 2, 7, 4, 6, 5, 0]}, {'array': [1, 7, 8, 10, 4, 3, 5, 2, 6, 0]}, {'array': [11, 0, 4, 6, 5, 10, 8, 7, 9, 1, 3]}, {'array': [1, 7, 9, 3, 10, 2, 11, 8, 0, 6, 12, 5]}, {'array': [2, 5, 1, 6, 0, 4]}]"
        },
        "outputs": [
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ],
        "meta": {
            "id": 61,
            "canonical_solution": "",
            "entry_point": "missing_number"
        }
    },
    "104": {
        "instruction": "Допишите код на языке Python в соответствии с условием, приведенным в описании\n{function}",
        "inputs": {
            "function": "def numbers_only(string: str) -> int:\n    \"\"\"Выведите количество уникальных целых чисел, которые образовались после замены всех нечисловых символов строки string на пробелы.\n    Примеры:\n       numbers_only(string=тву6бчуб758гтж1и19ришиирьечхо9жгщ4йф96ящ) == 7\n       numbers_only(string=з6к1241е989ъ2е2юп9н656ф7к3086стя17д2щ316ч58к491) == 12\n    \"\"\"",
            "tests": "[{'string': 'тву6бчуб758гтж1и19ришиирьечхо9жгщ4йф96ящ'}, {'string': 'з6к1241е989ъ2е2юп9н656ф7к3086стя17д2щ316ч58к491'}, {'string': 'ывбпоылфлоптыюловпт'}, {'string': 'яж7а9вю6псго5эъ38со7ш91ььу513уккм6щь3геш81ы14296'}, {'string': 'й1эа62р2п17м48683нх2856из7уз122й99х7э'}, {'string': 'г876ай7ьхя05зэ4932ош0р6'}, {'string': 'д5в2н4ы4т9уйд50я5и49кгю8ю'}, {'string': '2й4юсг511юзхбу298661юь858'}, {'string': ''}, {'string': 'ш1207щу828м546сег3юа5с5бе882юсв'}]"
        },
        "outputs": [
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ],
        "meta": {
            "id": 104,
            "canonical_solution": "",
            "entry_point": "numbers_only"
        }
    },
    "105": {
        "instruction": "Дано описание функции, напиши программу на языке Python\n{function}",
        "inputs": {
            "function": "from typing import List\n\n\ndef ascending_subarray(array: List[int]) -> int:\n    \"\"\"Выведите максимально возможную сумму какого-либо возрастающего непрерывного подсписка списка array, состоящего из целых чисел.\n    Примеры:\n       ascending_subarray(array=[11, 63, 10, 88, 0, 30, 20, 77, 70, 18, 14, 45, 51, 86]) == 196\n       ascending_subarray(array=[73, 80, 65, 88, 96, 3, 35, 72, 39, 55, 47, 86]) == 249\n    \"\"\"",
            "tests": "[{'array': [11, 63, 10, 88, 0, 30, 20, 77, 70, 18, 14, 45, 51, 86]}, {'array': [73, 80, 65, 88, 96, 3, 35, 72, 39, 55, 47, 86]}, {'array': [18, 90, 7, 61, 71, 34]}, {'array': [6, 24, 19, 17, 9, 0, 63, 33, 53, 81, 55]}, {'array': [98, 78, 9, 93, 60, 14, 79, 92, 40]}, {'array': [69, 99, 14, 99, 89, 17, 80, 17, 41, 92, 53]}, {'array': [97, 77, 41, 3, 60, 41, 36, 40]}, {'array': [89, 45, 91, 70, 44, 83, 18, 15]}, {'array': [93, 25, 14, 51, 36, 41, 0]}, {'array': [15, 69, 74, 55, 55, 60, 57, 12, 29, 63, 57, 83, 15]}]"
        },
        "outputs": [
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ],
        "meta": {
            "id": 105,
            "canonical_solution": "",
            "entry_point": "ascending_subarray"
        }
    },
    "42": {
        "instruction": "Напишите программу по строке документации\n{function}",
        "inputs": {
            "function": "def leap_year(number: int) -> str:\n    \"\"\"Определите, является ли год с номером number високосным. Високосный год либо делится на 400, либо не делится на 100 и делится на 4. Выведите \"Да\", если является, иначе выведите \"Нет\".\n    Примеры:\n       leap_year(number=2) == 'Нет'\n       leap_year(number=28) == 'Да'\n    \"\"\"",
            "tests": "[{'number': 2}, {'number': 28}, {'number': 400}, {'number': 1234}, {'number': 3568}, {'number': 8765}, {'number': 13}, {'number': 927}, {'number': 1200}, {'number': 1000}]"
        },
        "outputs": [
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ],
        "meta": {
            "id": 42,
            "canonical_solution": "",
            "entry_point": "leap_year"
        }
    },
    "145": {
        "instruction": "Дано описание функции, напиши программу на языке Python\n{function}",
        "inputs": {
            "function": "from typing import List\n\n\ndef maximum_profit(array: List[int]) -> int:\n    \"\"\"Дан список цен на облигации по дням array. Один раз за день можно либо продать, либо купить облигацию. На руках можно держать только одну облигацию. Выведите, какой максимальный доход от операций с облигациями можно получить при таких ценах. Доход не может быть меньше 0.\n    Примеры:\n       maximum_profit(array=[5, 13, 9, 2, 7, 7, 10, 13]) == 19\n       maximum_profit(array=[5, 8, 1, 6, 12]) == 14\n    \"\"\"",
            "tests": "[{'array': [5, 13, 9, 2, 7, 7, 10, 13]}, {'array': [5, 8, 1, 6, 12]}, {'array': [13, 11, 5, 3, 4, 2, 3, 14, 3]}, {'array': [14, 6, 12, 8, 10]}, {'array': [11, 14, 1, 8, 10, 11, 6]}, {'array': [3, 11, 6, 9, 1, 8, 14, 9, 2]}, {'array': [12, 14, 14, 5, 9, 6]}, {'array': [5, 4, 3, 2, 1]}, {'array': [5, 4, 4, 12, 14, 10, 12, 10]}, {'array': []}]"
        },
        "outputs": [
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ],
        "meta": {
            "id": 145,
            "canonical_solution": "",
            "entry_point": "maximum_profit"
        }
    },
    "130": {
        "instruction": "Реши задачу по программированию\n{function}",
        "inputs": {
            "function": "def remove_substring(string: str) -> int:\n    \"\"\"В строке string вы можете неограниченное количество раз удалять вхождения построк \"АБ\" и \"ВГ\". Выведите длину наименьшей возможной строки после всех удалений.\n    Примеры:\n       remove_substring(string=АБАБВГ) == 0\n       remove_substring(string=АБВГСДЕЖАБ) == 4\n    \"\"\"",
            "tests": "[{'string': 'АБАБВГ'}, {'string': 'АБВГСДЕЖАБ'}, {'string': 'АБЫЛКНВЭЫЗВГЫЗАБ'}, {'string': 'ДЛОИВАБАБЫ'}, {'string': 'ВШПНВГВБХ'}, {'string': 'ЫВЖЩШЩОАББАВ'}, {'string': 'ГВВГАББА'}, {'string': 'ВАБГ'}, {'string': 'АБЫЖДВАГВ'}, {'string': 'ШЛНПНФЫ'}]"
        },
        "outputs": [
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ],
        "meta": {
            "id": 130,
            "canonical_solution": "",
            "entry_point": "remove_substring"
        }
    },
    "88": {
        "instruction": "Необходимо написать код по условию из строковой переменной документации, следующей после функции(ий)\n{function}",
        "inputs": {
            "function": "from typing import List\n\n\ndef common_symbols(array: List[str]) -> List[str]:\n    \"\"\"В списке строк array найдите символы, которые встречаются в каждой из строк и выведите список из данных символов в лексикографическом порядке.\n    Примеры:\n       common_symbols(array=['ежззхкющц', 'скщйбвпьк', 'щчыв', 'огкээр', 'ячюпшм', 'щщсдткчвяа']) == []\n       common_symbols(array=['иннторяъф', 'еттижоъыфнюъ', 'умнтоюиьыяхй', 'ифчукоызгээ', 'исоэжнб']) == ['и', 'о']\n    \"\"\"",
            "tests": "[{'array': ['ежззхкющц', 'скщйбвпьк', 'щчыв', 'огкээр', 'ячюпшм', 'щщсдткчвяа']}, {'array': ['иннторяъф', 'еттижоъыфнюъ', 'умнтоюиьыяхй', 'ифчукоызгээ', 'исоэжнб']}, {'array': ['оащцтъшбвк', 'зкцаханфрс', 'эцюшэпчаювоз', 'алцоккщзаж', 'ииаяхжщбакц']}, {'array': ['ляькыакв', 'ьбокцхлощдз', 'тавэысжэчрр', 'яцк', 'нпеюф']}, {'array': ['цуюътнэ', 'лэркщмфжпфвю', 'пщщвьунюэйев', 'фсскчлцэуяюъ', 'лдчютйхсэу']}, {'array': ['рбумивджн', 'жюьюцеид', 'имзвцмпмсоэ', 'ззши', 'окэ', 'ребягщоумйую', 'юмаычук', 'окзсчсчежрн']}, {'array': ['соькехти', 'ьъийсзоукмаб', 'коцспямпшгг', 'ъытммсзщка', 'квас']}, {'array': ['ешккихху', 'крненкхукси', 'ьйгфвцхуцхшг', 'тбюфдухдфщгс', 'блухэяпач']}, {'array': ['мсешаокпбф', 'бтцдчийч', 'тммтьц', 'омд', 'ыфбамзф', 'цвхьт', 'пстытажъмзя', 'иющъфш', 'зкбьеен', 'птлгчжы', 'евыум', 'ощицг']}, {'array': ['хгмщоцэкегэю', 'пэгофтцаыщу', 'цчмгхащ', 'шщтбъгюыдип', 'ыуфсущугь']}]"
        },
        "outputs": [
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ],
        "meta": {
            "id": 88,
            "canonical_solution": "",
            "entry_point": "common_symbols"
        }
    },
    "11": {
        "instruction": "Реализуй функцию(ии) на языке Python\n{function}",
        "inputs": {
            "function": "def solve_equation(A: float, B: float, C: float, D: float) -> int:\n    \"\"\"На основании коэффициентов A, B, C, D определите, имеет ли решения уравнение (Ax + B) / (Cx + D) = 0. Если у уравнения есть хотя бы одно решение, выведите \"1\". Если ни одного решения, выведите \"0\".\n    Примеры:\n       solve_equation(A=3, B=-3, C=2, D=500) == 1\n       solve_equation(A=30, B=-3, C=2, D=-2) == 0\n    \"\"\"",
            "tests": "[{'A': 3, 'B': -3, 'C': 2, 'D': 500}, {'A': 30, 'B': -3, 'C': 2, 'D': -2}, {'A': 300000.0, 'B': 5000.0, 'C': 15000.0, 'D': 25}, {'A': 0, 'B': 0, 'C': 2, 'D': -2}, {'A': 300000.0, 'B': 5000.0, 'C': 15000.0, 'D': 25}, {'A': 0, 'B': 0, 'C': 0, 'D': 0}, {'A': 12, 'B': 6, 'C': 4, 'D': 2}, {'A': 100, 'B': -4, 'C': 9, 'D': -200}, {'A': 1, 'B': 8, 'C': 9, 'D': 5}, {'A': -3, 'B': 300, 'C': -20, 'D': 0.5}]"
        },
        "outputs": [
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ],
        "meta": {
            "id": 11,
            "canonical_solution": "",
            "entry_point": "solve_equation"
        }
    },
    "137": {
        "instruction": "По данному условию с фиксированной шапкой функции(ий) напиши программу\n{function}",
        "inputs": {
            "function": "def alternating_sum(number: int) -> int:\n    \"\"\"В целом числе number большем нуля все цифры с четными индексами имеют знак \"+\", а с нечетными – знак \"-\". Выведите сумму цифр числа number с учетом их знаков.\n    Примеры:\n       alternating_sum(number=4) == 4\n       alternating_sum(number=192) == -6\n    \"\"\"",
            "tests": "[{'number': 4}, {'number': 192}, {'number': 843}, {'number': 1230}, {'number': 273}, {'number': 876543}, {'number': 10}, {'number': 219}, {'number': 327}, {'number': 49729}]"
        },
        "outputs": [
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ],
        "meta": {
            "id": 137,
            "canonical_solution": "",
            "entry_point": "alternating_sum"
        }
    },
    "66": {
        "instruction": "На вход подается функция(ии) с описанием в виде строки docstring. В соответствии с описанием вам необходимо реализовать функцию(ии)\n{function}",
        "inputs": {
            "function": "def last_word(string: str) -> int:\n    \"\"\"Выведите длину последнего слова в строке string. Словом считается совокупность непробельных символов в строке, слева и справа от которого есть пробельный символ или начало/конец строки. Если строка пустая, выведите 0.\n    Примеры:\n       last_word(string=Аппетит приходит во время еды) == 3\n       last_word(string=Бедность не порок) == 5\n    \"\"\"",
            "tests": "[{'string': 'Аппетит приходит во время еды'}, {'string': 'Бедность не порок'}, {'string': 'Без труда не выловишь и рыбку из пруда'}, {'string': 'Бесплатный сыр, бывает- только в мышеловке'}, {'string': 'Бог шельму= метит'}, {'string': 'В здоровом теле – здоровый дух'}, {'string': 'Волков бояться – в лес не ходить'}, {'string': 'Глаза боятся, а руки делают'}, {'string': 'Готовь сани летом, а телегу зимой'}, {'string': 'Дарёному коню в зубы не смотрят'}]"
        },
        "outputs": [
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ],
        "meta": {
            "id": 66,
            "canonical_solution": "",
            "entry_point": "last_word"
        }
    },
    "30": {
        "instruction": "Реши задачу по программированию\n{function}",
        "inputs": {
            "function": "from typing import List\n\n\ndef max_product(array: List[int]) -> int:\n    \"\"\"В массиве array найдите три числа, которые дают наибольшее произведение и выведите значение данного произведения. Гарантируется, что array содержит не меньше 3 элементов.\n    Примеры:\n       max_product(array=[-11, -2, 2, -8, 2, -3, 19, 14, -9, -4, 14]) == 3724\n       max_product(array=[18, 16, -1, 9, -16, -6, -4, -1, 17, 18, -7, -16, -14, 6]) == 5508\n    \"\"\"",
            "tests": "[{'array': [-11, -2, 2, -8, 2, -3, 19, 14, -9, -4, 14]}, {'array': [18, 16, -1, 9, -16, -6, -4, -1, 17, 18, -7, -16, -14, 6]}, {'array': [17, 3, 0]}, {'array': [-8, 7, -20, 6, 8, -19, -16, -19, -8, -14, -16]}, {'array': [-15, 10, -5, 17, -7, -20, -12, 3, -18, -7, 10, -15]}, {'array': [-9, 4, 4, 5, 12, 0, -14, -18, -16, 7]}, {'array': [18, -1, 14, 0, 4, -19]}, {'array': [19, 7, 9, 6, -7, -9, 18, 9, -11, -5, 12]}, {'array': [13, -5, 8, 15, -4, 10, 4, 3]}, {'array': [1, 4, -1, -9, 5, 13, -13, 16, -16, -20]}]"
        },
        "outputs": [
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ],
        "meta": {
            "id": 30,
            "canonical_solution": "",
            "entry_point": "max_product"
        }
    },
    "124": {
        "instruction": "Допишите код на языке Python в соответствии с условием, приведенным в описании\n{function}",
        "inputs": {
            "function": "from typing import List\n\n\ndef distinct_quadruplets(array: List[int]) -> int:\n    \"\"\"Дан список целых положительных чисел array. Выведите количество четверок чисел из массива таких, что сумма первых трех равна четвертому, а также все числа разные и четвертое число строго больше любого из первых трех.\n    Примеры:\n       distinct_quadruplets(array=[18, 4, 19, 9, 2, 10, 14, 7, 0, 17, 14, 15, 16]) == 7\n       distinct_quadruplets(array=[5, 1, 10, 10, 0, 17, 1, 0, 16, 17, 14, 7, 6, 10]) == 16\n    \"\"\"",
            "tests": "[{'array': [18, 4, 19, 9, 2, 10, 14, 7, 0, 17, 14, 15, 16]}, {'array': [5, 1, 10, 10, 0, 17, 1, 0, 16, 17, 14, 7, 6, 10]}, {'array': [19, 7, 8, 14, 9, 12, 8, 6, 3, 16]}, {'array': [1, 16, 11, 3, 11, 1, 18, 18, 11, 11, 3, 19, 15]}, {'array': [4, 1, 3, 12, 9, 5, 3, 12, 0, 5, 17, 19]}, {'array': [0, 10, 9, 2, 6, 11, 6, 14]}, {'array': [3, 15, 3, 6, 2, 8, 16, 17, 19]}, {'array': [19, 6, 14, 12, 18, 0, 17, 13, 0, 10, 12, 8, 15, 14]}, {'array': [10, 10, 3, 7, 6, 10, 16, 3, 3, 9, 0, 13]}, {'array': [3, 12, 10, 17, 5, 12, 7, 17, 2, 5, 13, 5]}]"
        },
        "outputs": [
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ],
        "meta": {
            "id": 124,
            "canonical_solution": "",
            "entry_point": "distinct_quadruplets"
        }
    },
    "154": {
        "instruction": "Допишите код на языке Python в соответствии с условием, приведенным в описании\n{function}",
        "inputs": {
            "function": "def squares_factorization(number: int) -> str:\n    \"\"\"Определите, существуют ли ровно два целых числа, сумма квадратов которых дает в точности число number. Если существует, выведите \"Да\", иначе – \"Нет\".\n    Примеры:\n       squares_factorization(number=80) == 'Да'\n       squares_factorization(number=21) == 'Нет'\n    \"\"\"",
            "tests": "[{'number': 80}, {'number': 21}, {'number': 1}, {'number': 44}, {'number': 34}, {'number': 89}, {'number': 53}, {'number': 95}, {'number': 64}, {'number': 0}]"
        },
        "outputs": [
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ],
        "meta": {
            "id": 154,
            "canonical_solution": "",
            "entry_point": "squares_factorization"
        }
    },
    "18": {
        "instruction": "Необходимо написать код по условию из строковой переменной документации, следующей после функции(ий)\n{function}",
        "inputs": {
            "function": "def number_words(string: str) -> int:\n    \"\"\"Выведите количество слов в строке string. Словом считаются любые последовательности символов, которые отделены друг от друга пробелами.\n    Примеры:\n       number_words(string=Аппетит приходит во время еды) == 5\n       number_words(string=Бедность не порок) == 3\n    \"\"\"",
            "tests": "[{'string': 'Аппетит приходит во время еды'}, {'string': 'Бедность не порок'}, {'string': 'Без труда не выловишь и рыбку из пруда'}, {'string': 'Бесплатный сыр, бывает- только в мышеловке'}, {'string': 'Бог шельму= метит'}, {'string': 'В здоровом теле – здоровый дух'}, {'string': 'Волков бояться – в лес не ходить'}, {'string': 'Глаза боятся, а руки делают'}, {'string': 'Готовь сани летом, а телегу зимой'}, {'string': 'Дарёному коню в зубы не смотрят'}]"
        },
        "outputs": [
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ],
        "meta": {
            "id": 18,
            "canonical_solution": "",
            "entry_point": "number_words"
        }
    },
    "127": {
        "instruction": "По данному условию с фиксированной шапкой функции(ий) напиши программу\n{function}",
        "inputs": {
            "function": "def achieve_number(number: int, target: int) -> int:\n    \"\"\"Число называется красивым для числа target, если после совершения не более, чем number действий оно станет равно target. В качестве одного действия разрешается увеличивать target на 1 и одновременно уменьшать число на 1. Выведите максимально возможное красивое число для target.\n    Примеры:\n       achieve_number(number=34, target=81) == 149\n       achieve_number(number=27, target=48) == 102\n    \"\"\"",
            "tests": "[{'number': 34, 'target': 81}, {'number': 27, 'target': 48}, {'number': 36, 'target': 71}, {'number': 46, 'target': 219}, {'number': 25, 'target': 471}, {'number': 4, 'target': 490}, {'number': 23, 'target': 433}, {'number': 21, 'target': 35}, {'number': 4, 'target': 476}, {'number': 16, 'target': 272}]"
        },
        "outputs": [
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ],
        "meta": {
            "id": 127,
            "canonical_solution": "",
            "entry_point": "achieve_number"
        }
    },
    "121": {
        "instruction": "Реализуй функцию(ии) на языке Python\n{function}",
        "inputs": {
            "function": "def binary_inversion(number: int) -> int:\n    \"\"\"Дано число в десятичной системе счисления number. Инвертируйте биты в его двоичном представлении, запишите полученное двоичное число в обратном порядке и выведите его в десятичной системе счисления. Инверсия битов – это замена \"0\" на \"1\" и \"1\" на \"0\".\n    Примеры:\n       binary_inversion(number=4) == 6\n       binary_inversion(number=28) == 24\n    \"\"\"",
            "tests": "[{'number': 4}, {'number': 28}, {'number': 841}, {'number': 1234}, {'number': 9409}, {'number': 876543}, {'number': 6}, {'number': 25}, {'number': 3721}, {'number': 49729}]"
        },
        "outputs": [
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ],
        "meta": {
            "id": 121,
            "canonical_solution": "",
            "entry_point": "binary_inversion"
        }
    },
    "0": {
        "instruction": "Реши задачу по программированию\n{function}",
        "inputs": {
            "function": "def count_tens(number: int) -> int:\n    \"\"\"Выведите число десятков в натуральном числе number.\n    Примеры:\n       count_tens(number=1) == 0\n       count_tens(number=10) == 1\n    \"\"\"",
            "tests": "[{'number': 1}, {'number': 10}, {'number': 23}, {'number': 123456}, {'number': 666}, {'number': 409}, {'number': 81}, {'number': 42587}, {'number': 987346}, {'number': 1987347}]"
        },
        "outputs": [
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ],
        "meta": {
            "id": 0,
            "canonical_solution": "",
            "entry_point": "count_tens"
        }
    },
    "17": {
        "instruction": "По данному условию с фиксированной шапкой функции(ий) напиши программу\n{function}",
        "inputs": {
            "function": "def sum_inverse_squares(number: int) -> float:\n    \"\"\"Выведите сумму ряда обратных квадратов от 1 до числа number включительно (гарантируется, что number не превосходит 100). Ряд обратных квадратов – это последовательность чисел, каждое из которых представлено в виде (1/x) в квадрате. Округлите ответ до 2 знаков после запятой.\n    Примеры:\n       sum_inverse_squares(number=1) == 1.0\n       sum_inverse_squares(number=2) == 1.25\n    \"\"\"",
            "tests": "[{'number': 1}, {'number': 2}, {'number': 3}, {'number': 4}, {'number': 5}, {'number': 6}, {'number': 7}, {'number': 8}, {'number': 9}, {'number': 10}]"
        },
        "outputs": [
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ],
        "meta": {
            "id": 17,
            "canonical_solution": "",
            "entry_point": "sum_inverse_squares"
        }
    },
    "52": {
        "instruction": "Напишите программу по строке документации\n{function}",
        "inputs": {
            "function": "def even_indicies(string: str) -> str:\n    \"\"\"Дана строка string. Выведите строку, которая состоит из всех символов string, имеющих четный индекс. Если строка пустая, выведите ее.\n    Примеры:\n       even_indicies(string=Флюгегехаймен) == 'Фюееамн'\n       even_indicies(string=метафора) == 'мтфр'\n    \"\"\"",
            "tests": "[{'string': 'Флюгегехаймен'}, {'string': 'метафора'}, {'string': 'опщчтыклбуд'}, {'string': 'щфоцржусх'}, {'string': 'жвасчднтбр'}, {'string': 'овьцртгдся'}, {'string': 'тцсчюхаиовупгн'}, {'string': 'яысмънфпб'}, {'string': 'члзтуэбныещмокфъад'}, {'string': 'рщлэт'}]"
        },
        "outputs": [
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ],
        "meta": {
            "id": 52,
            "canonical_solution": "",
            "entry_point": "even_indicies"
        }
    },
    "123": {
        "instruction": "Необходимо реализовать логику на языке Python для следующей программы\n{function}",
        "inputs": {
            "function": "def double_inversion(number: int) -> str:\n    \"\"\"Дано целое число number. Дважды повторите разворот цифр записи числа в обратном порядке, удаляя ведущие нули. Если полученное число равно исходному, выведите \"Да\", иначе выведите \"Нет\".\n    Примеры:\n       duble_inversion(number=4) == 'Да'\n       duble_inversion(number=20) == 'Нет'\n    \"\"\"",
            "tests": "[{'number': 4}, {'number': 20}, {'number': 843}, {'number': 1230}, {'number': 9409}, {'number': 876543}, {'number': 10}, {'number': 250}, {'number': 3721}, {'number': 49729}]"
        },
        "outputs": [
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ],
        "meta": {
            "id": 123,
            "canonical_solution": "",
            "entry_point": "duble_inversion"
        }
    },
    "38": {
        "instruction": "Необходимо написать код по условию из строковой переменной документации, следующей после функции(ий)\n{function}",
        "inputs": {
            "function": "def closest_fibonacci(number: int) -> int:\n    \"\"\"Выведите ближайшее к числу number число Фибоначчи. Близость одного числа к другому определяется, как модуль разности данных чисел. Числа Фибоначчи – это такие числа, каждое из которых равно сумме двух предыдущих, а первое и второе равны единице. Если есть два подходящих под условие числа, выведите наименьшее из них.\n    Примеры:\n       closest_fibonacci(number=2) == 2\n       closest_fibonacci(number=28) == 34\n    \"\"\"",
            "tests": "[{'number': 2}, {'number': 28}, {'number': 387}, {'number': 1234}, {'number': 3568}, {'number': 876543}, {'number': 13}, {'number': 927}, {'number': 1453}, {'number': 98376}]"
        },
        "outputs": [
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ],
        "meta": {
            "id": 38,
            "canonical_solution": "",
            "entry_point": "closest_fibonacci"
        }
    },
    "72": {
        "instruction": "Напишите программу по строке документации\n{function}",
        "inputs": {
            "function": "def string_sum(string1: str, string2: str) -> str:\n    \"\"\"Два положительных челых числа даны в виде строк string1 и string2. Сложите эти числа и выведите ответ в виде строки. Гарантируется, что величина чисел соответствует типу данных int32.\n    Примеры:\n       string_sum(string1=411465, string2=218778) == '630243'\n       string_sum(string1=552226, string2=754815) == '1307041'\n    \"\"\"",
            "tests": "[{'string1': '411465', 'string2': '218778'}, {'string1': '552226', 'string2': '754815'}, {'string1': '785473', 'string2': '247575'}, {'string1': '540860', 'string2': '146017'}, {'string1': '828385', 'string2': '517570'}, {'string1': '195231', 'string2': '2895'}, {'string1': '731218', 'string2': '928361'}, {'string1': '777711', 'string2': '962434'}, {'string1': '833956', 'string2': '843254'}, {'string1': '642317', 'string2': '597263'}]"
        },
        "outputs": [
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ],
        "meta": {
            "id": 72,
            "canonical_solution": "",
            "entry_point": "string_sum"
        }
    },
    "132": {
        "instruction": "Напишите программу по строке документации\n{function}",
        "inputs": {
            "function": "from typing import List\n\n\ndef maximum_row(matrix: List[List[int]]) -> int:\n    \"\"\"Найдтите наименьшую по индексу строку в бинарной матрице matrix, которая содержит наибольшее количество единиц и выведите количество единиц в этой строке.\n    Примеры:\n       maximum_row(matrix=[[1, 0, 0, 0, 1, 1, 1, 0], [1, 1, 0, 1, 1, 0, 0, 1], [0, 1, 0, 0, 0, 0, 1, 0], [0, 0, 1, 1, 0, 0, 0, 0], [1, 0, 1, 1, 0, 0, 1, 1], [0, 0, 1, 0, 0, 1, 1, 0], [1, 1, 1, 0, 0, 0, 1, 0], [1, 0, 0, 1, 0, 1, 1, 1]]) == 5\n       maximum_row(matrix=[[0, 1, 0, 1, 0, 1, 1, 1, 1, 1], [0, 0, 0, 1, 0, 1, 1, 1, 0, 0], [0, 1, 1, 0, 0, 0, 1, 0, 1, 0], [1, 1, 1, 0, 0, 1, 1, 1, 0, 1], [0, 0, 0, 0, 0, 0, 0, 0, 1, 0], [1, 1, 0, 1, 0, 1, 0, 1, 0, 1], [1, 0, 1, 0, 0, 1, 0, 1, 0, 1], [0, 1, 0, 1, 0, 0, 1, 0, 0, 1], [0, 0, 0, 1, 1, 1, 1, 1, 1, 0], [0, 0, 0, 1, 0, 0, 1, 1, 1, 1]]) == 7\n    \"\"\"",
            "tests": "[{'matrix': [[1, 0, 0, 0, 1, 1, 1, 0], [1, 1, 0, 1, 1, 0, 0, 1], [0, 1, 0, 0, 0, 0, 1, 0], [0, 0, 1, 1, 0, 0, 0, 0], [1, 0, 1, 1, 0, 0, 1, 1], [0, 0, 1, 0, 0, 1, 1, 0], [1, 1, 1, 0, 0, 0, 1, 0], [1, 0, 0, 1, 0, 1, 1, 1]]}, {'matrix': [[0, 1, 0, 1, 0, 1, 1, 1, 1, 1], [0, 0, 0, 1, 0, 1, 1, 1, 0, 0], [0, 1, 1, 0, 0, 0, 1, 0, 1, 0], [1, 1, 1, 0, 0, 1, 1, 1, 0, 1], [0, 0, 0, 0, 0, 0, 0, 0, 1, 0], [1, 1, 0, 1, 0, 1, 0, 1, 0, 1], [1, 0, 1, 0, 0, 1, 0, 1, 0, 1], [0, 1, 0, 1, 0, 0, 1, 0, 0, 1], [0, 0, 0, 1, 1, 1, 1, 1, 1, 0], [0, 0, 0, 1, 0, 0, 1, 1, 1, 1]]}, {'matrix': [[0, 1, 0, 0, 1, 0], [0, 0, 0, 1, 1, 0], [1, 0, 0, 0, 1, 1], [0, 0, 0, 0, 1, 1], [1, 1, 1, 1, 1, 1], [1, 1, 1, 1, 0, 1]]}, {'matrix': [[0, 1, 0, 0, 1, 1, 1, 1, 1, 0, 0], [1, 0, 0, 1, 0, 1, 1, 0, 0, 1, 1], [1, 1, 1, 1, 0, 1, 1, 0, 1, 1, 1], [1, 1, 0, 1, 1, 1, 1, 0, 0, 0, 1], [1, 1, 0, 0, 0, 1, 0, 0, 0, 0, 1], [0, 1, 1, 1, 1, 1, 1, 0, 1, 0, 1], [0, 0, 0, 1, 1, 1, 0, 1, 0, 0, 0], [0, 0, 1, 1, 1, 0, 1, 0, 1, 0, 0], [1, 1, 0, 1, 1, 1, 0, 1, 0, 1, 1], [0, 1, 1, 0, 0, 0, 1, 0, 0, 0, 1], [1, 0, 0, 1, 0, 1, 0, 1, 0, 0, 0]]}, {'matrix': [[1, 1, 0, 0, 0], [1, 1, 1, 1, 1], [0, 1, 0, 0, 1], [1, 0, 0, 0, 1], [0, 0, 0, 1, 1]]}, {'matrix': [[0, 0, 1, 0, 1, 0, 1, 0, 1, 0, 0], [0, 1, 1, 0, 0, 0, 1, 0, 0, 1, 1], [1, 1, 0, 1, 1, 0, 1, 1, 1, 0, 0], [0, 1, 0, 0, 0, 1, 1, 0, 0, 0, 1], [0, 1, 0, 1, 0, 0, 0, 0, 0, 1, 1], [1, 1, 1, 0, 0, 1, 1, 0, 0, 1, 0], [1, 1, 1, 0, 1, 0, 1, 1, 1, 0, 1], [0, 0, 0, 1, 1, 1, 1, 0, 1, 1, 0], [1, 1, 1, 1, 0, 1, 1, 1, 1, 0, 0], [0, 1, 0, 1, 0, 0, 0, 1, 0, 1, 0], [0, 1, 1, 0, 0, 0, 1, 0, 0, 1, 1]]}, {'matrix': [[0, 1, 0, 0, 1, 0], [1, 1, 0, 0, 1, 0], [1, 1, 1, 1, 0, 0], [0, 0, 1, 1, 0, 1], [0, 1, 0, 0, 1, 1], [0, 1, 1, 0, 1, 0]]}, {'matrix': [[1, 0, 1, 0, 1, 1, 1, 0], [0, 0, 0, 1, 1, 1, 1, 1], [0, 1, 0, 1, 1, 1, 1, 0], [1, 0, 0, 0, 0, 1, 0, 0], [1, 1, 0, 1, 0, 1, 0, 0], [0, 0, 1, 1, 0, 1, 1, 1], [1, 0, 1, 1, 0, 1, 0, 1], [1, 0, 0, 1, 1, 1, 1, 0]]}, {'matrix': [[1, 1, 1, 1, 0, 0, 1, 1, 1, 1, 1], [1, 1, 0, 0, 1, 1, 1, 1, 1, 1, 0], [0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1], [1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0], [0, 1, 1, 1, 1, 0, 1, 1, 1, 1, 0], [1, 0, 0, 1, 1, 1, 0, 0, 0, 0, 1], [0, 1, 1, 0, 1, 1, 0, 1, 0, 0, 0], [1, 1, 1, 0, 1, 1, 0, 1, 0, 1, 0], [0, 1, 0, 0, 0, 1, 0, 0, 0, 1, 1], [0, 0, 0, 1, 0, 1, 0, 0, 0, 0, 1], [0, 0, 1, 1, 0, 1, 0, 0, 1, 1, 0]]}, {'matrix': [[0, 0, 0, 0, 0], [0, 1, 1, 1, 0], [0, 1, 1, 1, 0], [0, 0, 1, 0, 1], [1, 0, 1, 0, 1]]}]"
        },
        "outputs": [
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ],
        "meta": {
            "id": 132,
            "canonical_solution": "",
            "entry_point": "maximum_row"
        }
    },
    "95": {
        "instruction": "Дано описание функции, напиши программу на языке Python\n{function}",
        "inputs": {
            "function": "def three_divisors(number: int) -> str:\n    \"\"\"Дано целое число number. Определите количество натуральных делитетей данного числа. Выведите \"Да\", если таких делителей в точности 3. Иначе, выведите \"Нет\".\n    Примеры:\n       three_divisors(number=4) == 'Да'\n       three_divisors(number=28) == 'Нет'\n    \"\"\"",
            "tests": "[{'number': 4}, {'number': 28}, {'number': 841}, {'number': 1234}, {'number': 9409}, {'number': 876543}, {'number': 6}, {'number': 25}, {'number': 3721}, {'number': 49729}]"
        },
        "outputs": [
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ],
        "meta": {
            "id": 95,
            "canonical_solution": "",
            "entry_point": "three_divisors"
        }
    },
    "2": {
        "instruction": "Напишите программу по строке документации\n{function}",
        "inputs": {
            "function": "def clock_time(number: int) -> str:\n    \"\"\"Выведите сколько времени покажут часы, запущенные в полночь, спустя number секунд. Используйте 24-часовую систему. Выведите ответ в формате: HH:MM:SS. Если минуты или секунды меньше 10, добавьте в начало 0.\n    Примеры:\n       clock_time(number=25446) == '7:04:06'\n       clock_time(number=78799) == '21:53:19'\n    \"\"\"",
            "tests": "[{'number': 25446}, {'number': 78799}, {'number': 53553}, {'number': 72451}, {'number': 82128}, {'number': 15544}, {'number': 99469}, {'number': 59489}, {'number': 37318}, {'number': 169}]"
        },
        "outputs": [
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ],
        "meta": {
            "id": 2,
            "canonical_solution": "",
            "entry_point": "clock_time"
        }
    },
    "19": {
        "instruction": "Дан шаблон функции(ий) с описанием работы этой функции в качестве условия задачи. Допишите программу\n{function}",
        "inputs": {
            "function": "def swap_words(string: str) -> str:\n    \"\"\"В строке string из двух слов, разделенных пробелом, поменяйте местами слова и выведите получившуюся строку. Гарантируется, что string всегда содержит ровно два слова, разделенных пробелом.\n    Примеры:\n       swap_words(string=Аппетит приходиты) == 'приходиты Аппетит'\n       swap_words(string=Бедность не) == 'не Бедность'\n    \"\"\"",
            "tests": "[{'string': 'Аппетит приходиты'}, {'string': 'Бедность не'}, {'string': 'Без труда'}, {'string': 'Бесплатный сыр,'}, {'string': 'Бог шельму='}, {'string': 'В здоровом'}, {'string': 'Волков бояться'}, {'string': 'Глаза боятся,'}, {'string': 'Готовь сани'}, {'string': 'Дарёному коню'}]"
        },
        "outputs": [
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ],
        "meta": {
            "id": 19,
            "canonical_solution": "",
            "entry_point": "swap_words"
        }
    },
    "76": {
        "instruction": "На вход подается функция(ии) с описанием в виде строки docstring. В соответствии с описанием вам необходимо реализовать функцию(ии)\n{function}",
        "inputs": {
            "function": "def selfdividing_sum(start:int, end: int) -> int:\n    \"\"\"Выведите, сколько чисел между start и end (включительно) делятся на все свои цифры. Нули в числах игнорируйте.\n    Примеры:\n       selfdividing_sum(start=59, end=4828) == 225\n       selfdividing_sum(start=59, end=451) == 40\n    \"\"\"",
            "tests": "[{'start': 59, 'end': 4828}, {'start': 59, 'end': 451}, {'start': 17, 'end': 17}, {'start': 73, 'end': 2418}, {'start': 83, 'end': 917}, {'start': 53, 'end': 5027}, {'start': 54, 'end': 1764}, {'start': 20, 'end': 3306}, {'start': 40, 'end': 4001}, {'start': 16, 'end': 19}]"
        },
        "outputs": [
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ],
        "meta": {
            "id": 76,
            "canonical_solution": "",
            "entry_point": "selfdividing_sum"
        }
    },
    "109": {
        "instruction": "Дан шаблон функции(ий) с описанием работы этой функции в качестве условия задачи. Допишите программу\n{function}",
        "inputs": {
            "function": "def beautiful_string(string: str) -> str:\n    \"\"\"Строка является красивой, если в ней каждая буква встречается как в строчном, так и в прописном виде. Выведите наибольшую красивую подстроку строки string. Если таких строк больше одной, то выведите ту, что встречается раньше всего в string. Если красивых подстрок нет, то ответом будет пустая строка.\n    Примеры:\n       beautiful_string(string=ФлЮГегЕхаЙмЕН) == 'ГегЕ'\n       beautiful_string(string=метафора) == ''\n    \"\"\"",
            "tests": "[{'string': 'ФлЮГегЕхаЙмЕН'}, {'string': 'метафора'}, {'string': 'щшщмфйЗЕвщуэЬэЖДЬКиЭэнйпйхчФгкДЩФхОЗыв'}, {'string': 'жтУкОцяЛзуюлгюйлкНбазиХЯЬКЩИУвчДЛыщшъБ'}, {'string': 'ПиЦРяовчтТффнщшвЕБюнчМгЭЭчЩЪфжЯвЖсчвЮ'}, {'string': 'чЫъТцъФНЮАУдФЧВБдГЪЬхэДцЙЮНршпЩЛХбЭЪрэх'}, {'string': 'фТММснЕШВЙгйЬщЕрМъПДЧЕхШДФЪдУГкЮб'}, {'string': 'ЭЩгДДцЛЛШыИЦЗбсНЦшукЖКуЧНгУЧкОЮцА'}, {'string': 'РзжкбАусжМЧДРЯДЫожЛТпЧлАМслВшйаН'}, {'string': 'ыЛщЧрдЭВХЖЪюДВйбРъШшфлпВЪпмХэреГжце'}]"
        },
        "outputs": [
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ],
        "meta": {
            "id": 109,
            "canonical_solution": "",
            "entry_point": "beautiful_string"
        }
    },
    "67": {
        "instruction": "По данному условию с фиксированной шапкой функции(ий) напиши программу\n{function}",
        "inputs": {
            "function": "from typing import List\n\n\ndef transpose_array(array: List[List[int]]) -> List[List[int]]:\n    \"\"\"Вам дан непустой двумерный массив array в виде списка списков. Данный массив представляет собой квадратную матрицу. Транспонируйте данный массив и выведите результат. Транспонирование двумерного массива эквивалентно его перевороту вокруг основной диагонали (диагональ из левого верхнего элемена, идущая по всем элементам, у которых индекс троки и столбца совпадает) или замене индексов строк на индексы столбцов и наоборот.\n    Примеры:\n       transpose_array(array=[[3, 5, 12, 13, 11], [6, 12, 5, 1, 5], [5, 8, 6, 4, 13], [3, 6, 2, 4, 8], [14, 6, 8, 9, 4]]) == [[3, 6, 5, 3, 14], [5, 12, 8, 6, 6], [12, 5, 6, 2, 8], [13, 1, 4, 4, 9], [11, 5, 13, 8, 4]]\n       transpose_array(array=[[4, 5, 12, 11, 4, 10], [6, 6, 1, 13, 6, 6], [5, 13, 7, 4, 13, 4], [3, 4, 4, 10, 5, 8], [6, 6, 4, 12, 6, 10], [7, 8, 4, 12, 6, 5]]) == [[4, 6, 5, 3, 6, 7], [5, 6, 13, 4, 6, 8], [12, 1, 7, 4, 4, 4], [11, 13, 4, 10, 12, 12], [4, 6, 13, 5, 6, 6], [10, 6, 4, 8, 10, 5]]\n    \"\"\"",
            "tests": "[{'array': [[3, 5, 12, 13, 11], [6, 12, 5, 1, 5], [5, 8, 6, 4, 13], [3, 6, 2, 4, 8], [14, 6, 8, 9, 4]]}, {'array': [[4, 5, 12, 11, 4, 10], [6, 6, 1, 13, 6, 6], [5, 13, 7, 4, 13, 4], [3, 4, 4, 10, 5, 8], [6, 6, 4, 12, 6, 10], [7, 8, 4, 12, 6, 5]]}, {'array': [[12, 8, 3, 1], [7, 11, 1, 3], [10, 12, 5, 3], [11, 6, 2, 10]]}, {'array': [[4, 14, 14, 12, 14, 5], [1, 5, 14, 7, 8, 4], [3, 8, 4, 7, 10, 3], [6, 2, 8, 9, 11, 14], [12, 9, 5, 5, 4, 6], [2, 3, 3, 7, 8, 6]]}, {'array': [[12, 5, 8, 2], [11, 13, 9, 14], [8, 6, 9, 1], [5, 5, 12, 7]]}, {'array': [[7, 1, 3, 10, 13], [2, 14, 13, 7, 8], [12, 1, 14, 9, 11], [10, 8, 10, 1, 12], [12, 10, 1, 6, 12]]}, {'array': [[2, 10, 4, 7, 10], [6, 11, 6, 12, 1], [2, 10, 12, 14, 4], [14, 7, 3, 9, 6], [3, 4, 14, 8, 14]]}, {'array': [[10, 13, 5, 14], [4, 3, 3, 5], [11, 8, 11, 13], [3, 4, 10, 13]]}, {'array': [[1, 7, 6, 10, 7, 14], [5, 9, 8, 6, 10, 4], [8, 9, 4, 4, 8, 12], [1, 13, 8, 3, 2, 3], [14, 10, 4, 11, 9, 4], [13, 4, 12, 6, 13, 2]]}, {'array': [[9, 7, 6, 11, 4, 11, 14], [6, 4, 7, 14, 14, 3, 8], [13, 7, 10, 5, 9, 14, 14], [8, 7, 11, 8, 1, 3, 1], [7, 5, 11, 3, 13, 5, 13], [7, 3, 7, 2, 11, 14, 1], [11, 12, 13, 12, 7, 8, 14]]}]"
        },
        "outputs": [
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ],
        "meta": {
            "id": 67,
            "canonical_solution": "",
            "entry_point": "transpose_array"
        }
    },
    "159": {
        "instruction": "Дан шаблон функции(ий) с описанием работы этой функции в качестве условия задачи. Допишите программу\n{function}",
        "inputs": {
            "function": "from typing import List\n\n\ndef matrix_difference(matrix: List[List[int]], number: int) -> int:\n    \"\"\"Дана матрица целых чисел matrix и целое число number. Выберите из каждой строки матрицы по одному числу так, чтобы абсолютное значение разности суммы этих чисел и number была минимально возможным. Выведите значение получившейся абсолютной разности. Гарантируется, что matrix всегда имеет не менее 1 элемента.\n    Примеры:\n       matrix_difference(matrix=[[3, 3, 20, 49], [26, 17, 0, 10], [40, 4, 28, 48], [15, 5, 0, 27]], number=63) == 0\n       matrix_difference(matrix=[[35, 19, 46, 34, 44], [21, 9, 33, 33, 44], [5, 35, 44, 36, 34], [25, 34, 49, 6, 19], [11, 47, 40, 26, 20]], number=40) == 10\n    \"\"\"",
            "tests": "[{'matrix': [[3, 3, 20, 49], [26, 17, 0, 10], [40, 4, 28, 48], [15, 5, 0, 27]], 'number': 63}, {'matrix': [[35, 19, 46, 34, 44], [21, 9, 33, 33, 44], [5, 35, 44, 36, 34], [25, 34, 49, 6, 19], [11, 47, 40, 26, 20]], 'number': 40}, {'matrix': [[7, 8, 16], [19, 30, 7], [30, 40, 45]], 'number': 30}, {'matrix': [[5, 45, 23, 15, 10, 22], [44, 2, 37, 12, 3, 6], [1, 5, 30, 46, 24, 17], [38, 38, 24, 9, 18, 4], [38, 15, 24, 34, 29, 42], [35, 25, 45, 17, 39, 31]], 'number': 13}, {'matrix': [[27, 45, 38, 39, 44], [40, 41, 26, 9, 18], [2, 3, 4, 18, 42], [22, 33, 42, 14, 37], [37, 14, 29, 27, 4]], 'number': 18}, {'matrix': [[26, 1, 20, 32], [34, 46, 8, 42], [25, 13, 2, 19], [10, 13, 40, 10]], 'number': 3}, {'matrix': [[6, 1, 15, 37, 36, 45], [33, 8, 14, 5, 2, 33], [21, 21, 13, 18, 32, 25], [23, 10, 18, 23, 42, 45], [23, 9, 6, 30, 29, 8], [49, 47, 19, 48, 43, 36]], 'number': 30}, {'matrix': [[6, 43, 43], [21, 28, 45], [41, 8, 38]], 'number': 7}, {'matrix': [[16, 10, 12, 8, 37, 11], [5, 41, 14, 6, 33, 11], [30, 3, 7, 47, 36, 37], [49, 37, 48, 31, 5, 9], [15, 48, 23, 15, 25, 19], [1, 15, 6, 36, 2, 1]], 'number': 49}, {'matrix': [[49, 0, 47, 47], [39, 22, 42, 0], [14, 33, 33, 36], [5, 16, 3, 31]], 'number': 68}]"
        },
        "outputs": [
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ],
        "meta": {
            "id": 159,
            "canonical_solution": "",
            "entry_point": "matrix_difference"
        }
    },
    "158": {
        "instruction": "Необходимо написать код по условию из строковой переменной документации, следующей после функции(ий)\n{function}",
        "inputs": {
            "function": "def break_palindrome(string: str) -> str:\n    \"\"\"Дана строка string, которая содержит палиндром. Замените один символ в строке так, чтобы она перестала быть палиндромом и была минимальной из возможных в лексикографическом порядке. Если такой замены не существует, выведите пустую строку. Строка А лексикографически меньше строки В (той же длины), если в первой позиции слева, где А и В различаются, А имеет символ строго меньший (идет раньше в алфавите), чем соответствующий символ в В.\n    Примеры:\n       break_palindrome(string=атзттзта) == 'аазттзта'\n       break_palindrome(string=цшшц) == 'ашшц'\n    \"\"\"",
            "tests": "[{'string': 'атзттзта'}, {'string': 'цшшц'}, {'string': ''}, {'string': 'туиддиут'}, {'string': 'хюввюх'}, {'string': 'ьпъъпь'}, {'string': 'ржщщжр'}, {'string': 'нщннщн'}, {'string': 'мпсааспм'}, {'string': 'а'}]"
        },
        "outputs": [
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ],
        "meta": {
            "id": 158,
            "canonical_solution": "",
            "entry_point": "break_palindrome"
        }
    },
    "144": {
        "instruction": "Допишите код на языке Python в соответствии с условием, приведенным в описании\n{function}",
        "inputs": {
            "function": "from typing import List\n\n\ndef first_extremum(array: List[int]) -> int:\n    \"\"\"Дан список целых чисел array. Элемент списка называется экстремумом, если он больше своих соседей слева и справа. Крайний слева элемент всегда больше левого элемента, а крайний правый – элемента справа. Выведите индекс самого первого экстремума списка. Если такого индекса не существует, выведите -1.\n    Примеры:\n       first_extremum(array=[14, 4, 10, 8, 7, 13, 5, 10, 12, 6]) == 0\n       first_extremum(array=[6, 9, 13, 1, 10, 8]) == 2\n    \"\"\"",
            "tests": "[{'array': [14, 4, 10, 8, 7, 13, 5, 10, 12, 6]}, {'array': [6, 9, 13, 1, 10, 8]}, {'array': [6, 2, 7, 14, 6, 6, 14]}, {'array': [3, 5, 12, 4, 3]}, {'array': [5, 5, 4, 8, 10, 13, 6, 9, 8]}, {'array': [13, 12, 1, 11, 8, 6, 6, 5, 7, 5, 6]}, {'array': [11, 4, 13, 6, 7, 8, 13]}, {'array': [2, 13, 3, 11, 5, 7, 8]}, {'array': [3, 13, 5, 4, 9, 2, 9, 1]}, {'array': []}]"
        },
        "outputs": [
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ],
        "meta": {
            "id": 144,
            "canonical_solution": "",
            "entry_point": "first_extremum"
        }
    },
    "112": {
        "instruction": "Напишите программу по строке документации\n{function}",
        "inputs": {
            "function": "def largest_time(string: str) -> str:\n    \"\"\"Замените символ \"&\" в строке string на цифру таким образом, чтобы время, которое содержится в данной строке, было наиболее поздним в рамках одних суток. Формат записи времени \"HH:MM\" от 00:00 до 23:59. Выведите полученную строку.\n    Примеры:\n       largest_time(string=&1:29) == '21:29'\n       largest_time(string=10:&2) == '10:52'\n    \"\"\"",
            "tests": "[{'string': '&1:29'}, {'string': '10:&2'}, {'string': '&3:21'}, {'string': '12:&0'}, {'string': '20:&9'}, {'string': '&0:49'}, {'string': '&8:45'}, {'string': '&4:54'}, {'string': '&9:26'}, {'string': '21:3&'}]"
        },
        "outputs": [
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ],
        "meta": {
            "id": 112,
            "canonical_solution": "",
            "entry_point": "largest_time"
        }
    },
    "3": {
        "instruction": "Необходимо реализовать логику на языке Python для следующей программы\n{function}",
        "inputs": {
            "function": "def count_seconds(initial_time: str, final_time: str) -> int:\n    \"\"\"Вычислите сколько секунд прошло между тем, когда часы показывали initial_time и final_time. Между данными временными точками может пройти не более одних суток.\n    Примеры:\n       count_seconds(initial_time=00:00:00, final_time=00:00:00) == 0\n       count_seconds(initial_time=00:00:00, final_time=23:59:59) == 86399\n    \"\"\"",
            "tests": "[{'initial_time': '00:00:00', 'final_time': '00:00:00'}, {'initial_time': '00:00:00', 'final_time': '23:59:59'}, {'initial_time': '3:09:37', 'final_time': '23:15:12'}, {'initial_time': '03:09:37', 'final_time': '23:15:12'}, {'initial_time': '4:19:34', 'final_time': '18:49:53'}, {'initial_time': '10:02:52', 'final_time': '10:28:17'}, {'initial_time': '7:28:13', 'final_time': '11:43:35'}, {'initial_time': '19:20:41', 'final_time': '22:22:42'}, {'initial_time': '09:45:40', 'final_time': '15:46:31'}, {'initial_time': '18:20:48', 'final_time': '18:20:48'}]"
        },
        "outputs": [
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ],
        "meta": {
            "id": 3,
            "canonical_solution": "",
            "entry_point": "count_seconds"
        }
    },
    "102": {
        "instruction": "Напишите программу по строке документации\n{function}",
        "inputs": {
            "function": "def is_pangram(string: str) -> str:\n    \"\"\"Определите, является ли строка string панграммой. Панграмма – это такая строка, которая содержит все буквы русского алфавита, как минимум, один раз. Если является, выведите \"Да\", иначе, выведите \"Нет\".\n    Примеры:\n       is_pangram(string=Любя, съешь щипцы, — вздохнёт мэр, — кайф жгуч.) == 'Да'\n       is_pangram(string=Аппетит приходит во время еды) == 'Нет'\n    \"\"\"",
            "tests": "[{'string': 'Любя, съешь щипцы, — вздохнёт мэр, — кайф жгуч.'}, {'string': 'Аппетит приходит во время еды'}, {'string': 'Шеф взъярён тчк щипцы с эхом гудбай Жюль'}, {'string': 'Эй, жлоб! Где туз? Прячь юных съёмщиц в шкаф'}, {'string': 'Экс-граф? Плюш изъят. Бьём чуждый цен хвощ!'}, {'string': 'Чушь: гид вёз кэб цапф, юный жмот съел хрящ'}, {'string': 'Без труда не выловишь и рыбку из пруда'}, {'string': 'Готовь сани летом, а телегу зимой'}, {'string': 'Дарёному коню в зубы не смотрят'}, {'string': ''}]"
        },
        "outputs": [
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ],
        "meta": {
            "id": 102,
            "canonical_solution": "",
            "entry_point": "is_pangram"
        }
    },
    "54": {
        "instruction": "Допишите код на языке Python в соответствии с условием, приведенным в описании\n{function}",
        "inputs": {
            "function": "from typing import List\n\n\ndef max_count(array: List[int]) -> int:\n    \"\"\"Вам дан массив из целых чисел array, отсортированный в порядке неубывания. Каких чисел в массиве больше: положительных или отрицательных? Выведите число 1, если положительных, число -1, если отрицательных, и число 0, если их поровну. Число 0 в массиве не считается ни положительным, ни отрицательным. Гарантируется, что массив не пуст. Если массив содержит только число 0, в ответе выведите число 0.\n    Примеры:\n       max_count(array=[-42, 43, 12, 36, 9, 17, -38, -9, 9, 46, -2]) == 1\n       max_count(array=[-8, -25, 4, -2, 49, -14]) == -1\n    \"\"\"",
            "tests": "[{'array': [-42, 43, 12, 36, 9, 17, -38, -9, 9, 46, -2]}, {'array': [-8, -25, 4, -2, 49, -14]}, {'array': [10, 37, 49, 33, 39, -39, -30, 30]}, {'array': [32, 0, -49, 13, 39, -13, -44, 21, -33, -45, 22]}, {'array': [-50, 1, -25, -26, -11, 35, 2]}, {'array': [-43, 0, -38, 39, -7, -31]}, {'array': [30, -48, -14, 26, 11, 31, 38]}, {'array': [-5, 34, 1, -38, 38, 27, -21, -45, -3, 26, 31, 43]}, {'array': [-24, 12, -32, -2, 46, 29]}, {'array': [33, -16, -22, 39, 23, -16, 33, 49, 47, 6, 1, 40, 34, -9]}]"
        },
        "outputs": [
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ],
        "meta": {
            "id": 54,
            "canonical_solution": "",
            "entry_point": "max_count"
        }
    },
    "32": {
        "instruction": "Напишите программу по строке документации\n{function}",
        "inputs": {
            "function": "def dirichlet_rabbits(num_cages: int, num_rabbits: int) -> int:\n    \"\"\"Если есть num_cages клеток для кроликов, по которым рассадили num_rabbits кроликов, то какое наибольшее количество кроликов может оказаться в одной клетке? Кролики рассаживаются по клеткам равномерно. Это значит, что можно сажать кролика только в клетку, в которой меньше всего кроликов. Выведите получившееся число.\n    Примеры:\n       dirichlet_rabbits(num_cages=33, num_rabbits=3) == 1\n       dirichlet_rabbits(num_cages=25, num_rabbits=2) == 1\n    \"\"\"",
            "tests": "[{'num_cages': 33, 'num_rabbits': 3}, {'num_cages': 25, 'num_rabbits': 2}, {'num_cages': 4, 'num_rabbits': 6}, {'num_cages': 253, 'num_rabbits': 254}, {'num_cages': 1, 'num_rabbits': 0}, {'num_cages': 255, 'num_rabbits': 65535}, {'num_cages': 54475474574, 'num_rabbits': 9876342156547}, {'num_cages': 44, 'num_rabbits': 144}, {'num_cages': 22, 'num_rabbits': 44}, {'num_cages': 22, 'num_rabbits': 45}]"
        },
        "outputs": [
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ],
        "meta": {
            "id": 32,
            "canonical_solution": "",
            "entry_point": "dirichlet_rabbits"
        }
    },
    "75": {
        "instruction": "Дано описание функции, напиши программу на языке Python\n{function}",
        "inputs": {
            "function": "from typing import List\n\n\ndef smallest_symbol(array: List[str], symbol: str) -> str:\n    \"\"\"Если в непустом списке array существуют символы, которые лексикографически больше символа symbol, то выведите лексикографически наименьший из этих символов. Иначе, выведите первый символ списка array. По лексикографическому порядку один символ меньше другого, если идет раньше его в алфавите.\n    Примеры:\n       smallest_symbol(array=['х', 'щ', 'з', 'ж', 'й', 'ж', 'к', 'ф', 'т', 'е', 'ф'], symbol=х) == 'щ'\n       smallest_symbol(array=['о', 'а', 'х', 'г', 'п', 'э', 'б', 'щ', 'п', 'щ', 'ч', 'с', 'в', 'н', 'э', 'х'], symbol=л) == 'н'\n    \"\"\"",
            "tests": "[{'array': ['х', 'щ', 'з', 'ж', 'й', 'ж', 'к', 'ф', 'т', 'е', 'ф'], 'symbol': 'х'}, {'array': ['о', 'а', 'х', 'г', 'п', 'э', 'б', 'щ', 'п', 'щ', 'ч', 'с', 'в', 'н', 'э', 'х'], 'symbol': 'л'}, {'array': ['т', 'ц', 'д', 'ш', 'й', 'к', 'й', 'а', 'з', 'е', 'ь', 'е', 'р'], 'symbol': 'о'}, {'array': ['ф', 'ц', 'ъ', 'ф', 'в', 'н', 'и', 'ф', 'х', 'е', 'я', 'к', 'ы', 'в', 'ю', 'у'], 'symbol': 'ю'}, {'array': ['л', 'й', 'т', 'ш', 'о', 'т', 'з', 'г', 'ъ', 'ю'], 'symbol': 'ь'}, {'array': ['ч', 'э', 'ю', 'а', 'у', 'э', 'х', 'е', 'у', 'я', 'й', 'к', 'г'], 'symbol': 'м'}, {'array': ['и', 'ж', 'щ', 'т', 'д', 'н', 'х', 'в', 'х', 'х', 'н', 'в', 'э', 'б', 'к', 'т'], 'symbol': 'ж'}, {'array': ['н', 'м', 'л', 'п', 'ч', 'п', 'ю', 'г', 'я', 'х', 'и', 'щ', 'ь', 'э', 'у'], 'symbol': 'д'}, {'array': ['п', 'ш', 'ш', 'н', 'м', 'ф', 'х', 'у', 'к', 'в', 'ц', 'р', 'т', 'б'], 'symbol': 'о'}, {'array': ['ж', 'с', 'ъ', 'н', 'ж', 'н', 'н', 'б', 'э', 'ю'], 'symbol': 'ъ'}]"
        },
        "outputs": [
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ],
        "meta": {
            "id": 75,
            "canonical_solution": "",
            "entry_point": "smallest_symbol"
        }
    },
    "14": {
        "instruction": "Допишите код на языке Python в соответствии с условием, приведенным в описании\n{function}",
        "inputs": {
            "function": "def closest_degree(number: int) -> int:\n    \"\"\"Выведите наименьшее возможное число такое, что 2 в степени данного числа не меньше числа number. Гарантируется, что number не превосходит 1000000.\n    Примеры:\n       closest_degree(number=2) == 1\n       closest_degree(number=28) == 5\n    \"\"\"",
            "tests": "[{'number': 2}, {'number': 28}, {'number': 387}, {'number': 1234}, {'number': 3568}, {'number': 876543}, {'number': 13}, {'number': 927}, {'number': 1453}, {'number': 98376}]"
        },
        "outputs": [
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ],
        "meta": {
            "id": 14,
            "canonical_solution": "",
            "entry_point": "closest_degree"
        }
    },
    "128": {
        "instruction": "Необходимо написать код по условию из строковой переменной документации, следующей после функции(ий)\n{function}",
        "inputs": {
            "function": "def triple_concatenation(number: int) -> str:\n    \"\"\"Соедините число number с числами 2 * number и 3 * number. Если полученное число содержит все цифры от 1 до 9, но не содержит 0, то выведите \"Да\", в ином случае выведите \"Нет\".\n    Примеры:\n       triple_concatenation(number=4) == 'Нет'\n       triple_concatenation(number=192) == 'Да'\n    \"\"\"",
            "tests": "[{'number': 4}, {'number': 192}, {'number': 843}, {'number': 1230}, {'number': 273}, {'number': 876543}, {'number': 10}, {'number': 219}, {'number': 327}, {'number': 49729}]"
        },
        "outputs": [
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ],
        "meta": {
            "id": 128,
            "canonical_solution": "",
            "entry_point": "triple_concatenation"
        }
    },
    "53": {
        "instruction": "Необходимо реализовать логику на языке Python для следующей программы\n{function}",
        "inputs": {
            "function": "def find_lcm(A: int, B: int) -> int:\n    \"\"\"Выведите наименьшее общее кратное чисел A и B. Наименьшее общее кратное двух чисел – это такое число, которое делится без остатка и на A, и на B и является наименьшим возможным таким числом.\n    Примеры:\n       find_lcm(A=33, B=3) == 33\n       find_lcm(A=25, B=2) == 50\n    \"\"\"",
            "tests": "[{'A': 33, 'B': 3}, {'A': 25, 'B': 2}, {'A': 4, 'B': 6}, {'A': 253, 'B': 254}, {'A': 1, 'B': 0}, {'A': 255, 'B': 65535}, {'A': 54475474574, 'B': 9876342156547}, {'A': 144, 'B': 4}, {'A': 43, 'B': 45}, {'A': 85, 'B': 22}]"
        },
        "outputs": [
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ],
        "meta": {
            "id": 53,
            "canonical_solution": "",
            "entry_point": "find_lcm"
        }
    },
    "43": {
        "instruction": "Необходимо реализовать логику на языке Python для следующей программы\n{function}",
        "inputs": {
            "function": "def chess_field(coordinateA: str, coordinateB: str) -> str:\n    \"\"\"Вам даны координаты двух фигур на шахматной доске в формате строки: буквы и цифры без разделителя (А5, В7 и т.п.): coordinateA, coordinateB. Определите, одинаковые ли цвета у ячеек, на которых расположены данные фигуры. Если одинаковые, выведите \"Да\", иначе выведите \"Нет\".\n    Примеры:\n       chess_field(coordinateA=B5, coordinateB=D6) == 'Нет'\n       chess_field(coordinateA=B2, coordinateB=C1) == 'Да'\n    \"\"\"",
            "tests": "[{'coordinateA': 'B5', 'coordinateB': 'D6'}, {'coordinateA': 'B2', 'coordinateB': 'C1'}, {'coordinateA': 'H5', 'coordinateB': 'A4'}, {'coordinateA': 'H1', 'coordinateB': 'D1'}, {'coordinateA': 'E8', 'coordinateB': 'C7'}, {'coordinateA': 'G3', 'coordinateB': 'A1'}, {'coordinateA': 'C3', 'coordinateB': 'D3'}, {'coordinateA': 'F5', 'coordinateB': 'E2'}, {'coordinateA': 'G8', 'coordinateB': 'F5'}, {'coordinateA': 'H7', 'coordinateB': 'H1'}]"
        },
        "outputs": [
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ],
        "meta": {
            "id": 43,
            "canonical_solution": "",
            "entry_point": "chess_field"
        }
    },
    "63": {
        "instruction": "Необходимо реализовать логику на языке Python для следующей программы\n{function}",
        "inputs": {
            "function": "def add_digits(number: int) -> int:\n    \"\"\"Вам дано положительное целое число number. Складывайте все цифры данного числа до тех пор пока не останется всего одной цифры. Выведите получившуюся цифру.\n    Примеры:\n       add_digits(number=2) == 2\n       add_digits(number=28) == 1\n    \"\"\"",
            "tests": "[{'number': 2}, {'number': 28}, {'number': 387}, {'number': 1234}, {'number': 3568}, {'number': 876543}, {'number': 13}, {'number': 927}, {'number': 1453}, {'number': 98376}]"
        },
        "outputs": [
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ],
        "meta": {
            "id": 63,
            "canonical_solution": "",
            "entry_point": "add_digits"
        }
    },
    "99": {
        "instruction": "Дан шаблон функции(ий) с описанием работы этой функции в качестве условия задачи. Допишите программу\n{function}",
        "inputs": {
            "function": "from typing import List\n\n\ndef shuffle_array(array: List[int]) -> List[int]:\n    \"\"\"Дан список array из целых чисел от 0 до длины array минус 1 включительно. Постройте на основе списка array новый список, i-й элемент которого равен array[array[i]] для всех i от 0 до длины списка array. Выведите полученный список.\n    Примеры:\n       shuffle_array(array=[1, 0, 3, 2, 4]) == [0, 1, 2, 3, 4]\n       shuffle_array(array=[5, 1, 0, 4, 2, 3]) == [3, 1, 5, 2, 0, 4]\n    \"\"\"",
            "tests": "[{'array': [1, 0, 3, 2, 4]}, {'array': [5, 1, 0, 4, 2, 3]}, {'array': [3, 5, 0, 7, 4, 6, 1, 2]}, {'array': [1, 4, 7, 5, 3, 6, 2, 0]}, {'array': [8, 7, 6, 9, 4, 2, 1, 0, 3, 11, 5, 10]}, {'array': [5, 6, 2, 4, 7, 8, 3, 0, 1]}, {'array': [0, 3, 5, 1, 4, 6, 2, 7]}, {'array': [3, 0, 2, 6, 7, 1, 4, 5]}, {'array': [7, 3, 6, 1, 12, 2, 11, 0, 10, 5, 4, 13, 9, 8]}, {'array': [1, 4, 3, 0, 2]}]"
        },
        "outputs": [
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ],
        "meta": {
            "id": 99,
            "canonical_solution": "",
            "entry_point": "shuffle_array"
        }
    },
    "49": {
        "instruction": "Дан шаблон функции(ий) с описанием работы этой функции в качестве условия задачи. Допишите программу\n{function}",
        "inputs": {
            "function": "def change_symbol(string: str, symbol: str, another_symbol: str) -> str:\n    \"\"\"В строке string замените все вхождения символа symbol на another_symbol. Выведите получившуюся строку.\n    Примеры:\n       change_symbol(string=@$улк, symbol=$, another_symbol=0) == '@0улк'\n       change_symbol(string=й§чей*р/пи?ъгмр, symbol=/, another_symbol=3) == 'й§чей*р3пи?ъгмр'\n    \"\"\"",
            "tests": "[{'string': '@$улк', 'symbol': '$', 'another_symbol': '0'}, {'string': 'й§чей*р/пи?ъгмр', 'symbol': '/', 'another_symbol': '3'}, {'string': 'тун+?е~§г?', 'symbol': '~', 'another_symbol': '1'}, {'string': '§вхгз/ыйуч*з', 'symbol': '/', 'another_symbol': '2'}, {'string': 'яю/цанйю+р+веёсо*нз', 'symbol': '+', 'another_symbol': '1'}, {'string': 'ткёё?§в', 'symbol': '?', 'another_symbol': '9'}, {'string': 'ивт$у*й', 'symbol': '*', 'another_symbol': '8'}, {'string': '/зляе/втд$жгкъф§*', 'symbol': '$', 'another_symbol': '7'}, {'string': '/у§пн', 'symbol': '§', 'another_symbol': '2'}, {'string': 'п/?@та@геььз*пёяфоцх', 'symbol': '@', 'another_symbol': '4'}]"
        },
        "outputs": [
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ],
        "meta": {
            "id": 49,
            "canonical_solution": "",
            "entry_point": "change_symbol"
        }
    },
    "65": {
        "instruction": "Дано описание функции, напиши программу на языке Python\n{function}",
        "inputs": {
            "function": "def is_isomorphic(stringA: str, stringB: str) -> str:\n    \"\"\"Определите, являются ли строки stringA и stringB изморфными по отношению друг к другу. Две строки изоморфны, если символы одной строки могут быть заменены на другие, и получится вторая строка. Заменять разрешается все вхождения одного символа на другой символ одновременно. Если являются, выведите \"Да\", иначе выведите \"Нет\".\n    Примеры:\n       is_isomorphic(stringA=флюгегехаймен, stringB=щбятутуйвдсуз) == 'Да'\n       is_isomorphic(stringA=словесник, stringB=кзжидъшун) == 'Нет'\n    \"\"\"",
            "tests": "[{'stringA': 'флюгегехаймен', 'stringB': 'щбятутуйвдсуз'}, {'stringA': 'словесник', 'stringB': 'кзжидъшун'}, {'stringA': 'метафора', 'stringB': 'эзведяне'}, {'stringA': 'бортпроводник', 'stringB': 'лжвъцвжшжябою'}, {'stringA': 'девиация', 'stringB': 'иечобгмб'}, {'stringA': 'дублон', 'stringB': 'тяэтзм'}, {'stringA': 'жаловаться', 'stringB': 'пмвчихйфьй'}, {'stringA': 'диссонанс', 'stringB': 'ыеггкьбьг'}, {'stringA': 'заполучить', 'stringB': 'взкеьующон'}, {'stringA': 'изборник', 'stringB': 'эуэщяжге'}]"
        },
        "outputs": [
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ],
        "meta": {
            "id": 65,
            "canonical_solution": "",
            "entry_point": "is_isomorphic"
        }
    },
    "118": {
        "instruction": "Необходимо написать код по условию из строковой переменной документации, следующей после функции(ий)\n{function}",
        "inputs": {
            "function": "def decode_message(string: str, target: str) -> str:\n    \"\"\"Сделайте словарь, где в key записывается каждый из символов строки string по порядку по его первому вхождению в строку, а в value – символы русского алфавита по порядку. Используя полученные пары чисел key: value, замените все символы в строке target по словарю и выведите получившуюся строку, сохраняя пробелы на изначальных местах. Не учитывайте букву \"ё\" при кодировании и декодировании.\n    Примеры:\n       decode_message(string=ьсгыфлущншваяйеюдмхчиэбркпзъжцот, target=ьююлхнх юднэефнх ге гдлят лфъ) == 'аппетит приходит во время еды'\n       decode_message(string=чхпбоясуьылюэтйшцегимжвдкрназфъщ, target=хяотйегз тя шйцйл) == 'бедность не порок'\n    \"\"\"",
            "tests": "[{'string': 'ьсгыфлущншваяйеюдмхчиэбркпзъжцот', 'target': 'ьююлхнх юднэефнх ге гдлят лфъ'}, {'string': 'чхпбоясуьылюэтйшцегимжвдкрназфъщ', 'target': 'хяотйегз тя шйцйл'}, {'string': 'бжхпнсоцяемъгэиюйфщлазывукшрчдть', 'target': 'жсц щйлнб эс хръихяуч я йржмл яц юйлнб'}, {'string': 'щлиьжвтоъфяхрпгзкбйчашумюэнедсыц', 'target': 'лвбзхщйпеф бек леищвй йгхдяг и реювхгияв'}, {'string': 'лыгмтьрхъцодсфюбжвчеакиэунязйщпш', 'target': 'ыюм уьдйсе сьчъч'}, {'string': 'плиячгьцшщаотжюэъбнрефыкдзхуйсмв', 'target': 'и цчюъюиют нгог цчюъюиущ чрф'}, {'string': 'гцмэпйианюяхсърщчкольвтдзуфшбжеы', 'target': 'мрхярм црыобкы м хйк ъй врпноб'}, {'string': 'пваыюесшцгфлндчязйоъжкьщтэбиухрм', 'target': 'ылпшп вчмойм п зъфц юелпро'}, {'string': 'бзмяеыйвщьтлсхндцэгшюроиучъапфкж', 'target': 'янгнмп эбхщ лыгнс б гылыяш вщснь'}, {'string': 'ущмзаелжцвсдпгтнихкбчэьйыфшоюряъ', 'target': 'ауиегтпб стгя м жбщо ге хпткиък'}]"
        },
        "outputs": [
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ],
        "meta": {
            "id": 118,
            "canonical_solution": "",
            "entry_point": "decode_message"
        }
    },
    "115": {
        "instruction": "Дано описание функции, напиши программу на языке Python\n{function}",
        "inputs": {
            "function": "def largest_substring(string: str) -> int:\n    \"\"\"Выведите длину наибольшей непрерывной подстроки, заключенной между двумя одинаковыми символами в строке string, не считая сами данные символы. Символы-границы могут повторяться внутри подстроки. Если такой строки не существует, выведите -1.\n    Примеры:\n       largest_substring(string=флюгегехаймен) == 6\n       largest_substring(string=метафора) == 3\n    \"\"\"",
            "tests": "[{'string': 'флюгегехаймен'}, {'string': 'метафора'}, {'string': 'вжзцчтэпуюымп'}, {'string': 'зяцбтвноецапшоенцо'}, {'string': 'емърпысмыъщмыъмщй'}, {'string': 'вфърйтпечйосшюрвхйшгья'}, {'string': 'южбгцгжюгфлшззбвшмефзгормдхвгсзъюлысбв'}, {'string': 'ерщднлтгсмяяаршфсэнкьрлйки'}, {'string': 'кфлмзощсяшуэщяосдовдулкцнаэнцнгав'}, {'string': 'ащйзасадхзудъьхрнъь'}, {'string': 'зъгкмжвюгжнъб'}, {'string': 'ъшпвлпцбхцг'}]"
        },
        "outputs": [
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ],
        "meta": {
            "id": 115,
            "canonical_solution": "",
            "entry_point": "largest_substring"
        }
    },
    "64": {
        "instruction": "Допишите код на языке Python в соответствии с условием, приведенным в описании\n{function}",
        "inputs": {
            "function": "def is_anagram(string: str, another_string: str) -> str:\n    \"\"\"Определите, является ли строка string анаграммой строки another_string. Строка является анаграммой другой строки если состоит из тех же символов, что и изначальная строка, но в другом порядке. Если является, выведите \"Да\", иначе выведите \"Нет\".\n    Примеры:\n       is_anagram(string=заполучить, another_string=ьоачиузлпт) == 'Да'\n       is_anagram(string=жаловаться, another_string=пхкэгткуйн) == 'Нет'\n    \"\"\"",
            "tests": "[{'string': 'заполучить', 'another_string': 'ьоачиузлпт'}, {'string': 'жаловаться', 'another_string': 'пхкэгткуйн'}, {'string': 'дублон', 'another_string': 'ыгъсес'}, {'string': 'бортпроводник', 'another_string': 'товнордобпирк'}, {'string': 'диссонанс', 'another_string': 'аинондссс'}, {'string': 'изборник', 'another_string': 'лнфаыцяе'}, {'string': 'флюгегехаймен', 'another_string': 'ехлйнафеемггю'}, {'string': 'метафора', 'another_string': 'рфмаеоат'}, {'string': 'словесник', 'another_string': 'кндцмцаще'}, {'string': 'девиация', 'another_string': 'рфтейпек'}]"
        },
        "outputs": [
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ],
        "meta": {
            "id": 64,
            "canonical_solution": "",
            "entry_point": "is_anagram"
        }
    },
    "16": {
        "instruction": "На вход подается функция(ии) с описанием в виде строки docstring. В соответствии с описанием вам необходимо реализовать функцию(ии)\n{function}",
        "inputs": {
            "function": "from typing import List\n\n\ndef max_equal_subseq(array: List[int]) -> int:\n    \"\"\"Выведите длину наибольшей подряд идущей подпоследовательности из одинаковых чисел в последовательности array.\n    Примеры:\n       max_equal_subseq(array=[1, 5, 9, 7, 2, 6, 1, 2, 4, 9, 1]) == 1\n       max_equal_subseq(array=[2, 7, 7, 7, 3, 7, 5, 2, 1, 3]) == 3\n    \"\"\"",
            "tests": "[{'array': [1, 5, 9, 7, 2, 6, 1, 2, 4, 9, 1]}, {'array': [2, 7, 7, 7, 3, 7, 5, 2, 1, 3]}, {'array': [7, 2, 7, 9, 5, 1, 4]}, {'array': [4, 2, 1, 6, 2, 7, 1, 2]}, {'array': [6, 6, 1, 3, 7, 2, 1, 7, 3, 5, 8, 2]}, {'array': [4, 1, 3, 4, 9, 1, 6, 2, 1, 4]}, {'array': [9, 6, 1, 5, 1, 2, 9]}, {'array': [1, 2, 5, 1, 4, 5, 6, 1, 6, 4, 5, 7, 4]}, {'array': [4, 2, 5, 7, 5, 2, 1, 6, 6, 7, 1, 6, 7, 4]}, {'array': [1, 7, 3, 4, 4, 9, 2]}]"
        },
        "outputs": [
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ],
        "meta": {
            "id": 16,
            "canonical_solution": "",
            "entry_point": "max_equal_subseq"
        }
    },
    "83": {
        "instruction": "Необходимо реализовать логику на языке Python для следующей программы\n{function}",
        "inputs": {
            "function": "def single_change(number: int) -> int:\n    \"\"\"Выведите максимально возможное число, которое можно получить из числа number заменой только одной цифры в нем на 6 или 9. Число number состоит только из 6 и 9.\n    Примеры:\n       single_change(number=6) == 9\n       single_change(number=69) == 99\n    \"\"\"",
            "tests": "[{'number': 6}, {'number': 69}, {'number': 999}, {'number': 6969}, {'number': 9696}, {'number': 9999}, {'number': 669}, {'number': 96969}, {'number': 6699}, {'number': 9}]"
        },
        "outputs": [
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ],
        "meta": {
            "id": 83,
            "canonical_solution": "",
            "entry_point": "single_change"
        }
    },
    "69": {
        "instruction": "Дан шаблон функции(ий) с описанием работы этой функции в качестве условия задачи. Допишите программу\n{function}",
        "inputs": {
            "function": "from typing import List\n\n\ndef hour_glass(array: List[int], number: int) -> int:\n    \"\"\"Песочные часы отмеряют number секунд. Дан список array, который содержит время в секундах, когда песочные часы переворачиваются. Если песочные часы не закончили работу, но были перевернуты, то время их работы начинает течь заново. Выведите, сколько времени суммарно проработают песочные часы.\n    Примеры:\n       hour_glass(array=[0, 5, 8, 12, 15, 18, 22, 25, 28, 28, 33, 37], number=2) == 22\n       hour_glass(array=[0, 4, 9, 14, 14, 17, 19], number=3) == 17\n    \"\"\"",
            "tests": "[{'array': [0, 5, 8, 12, 15, 18, 22, 25, 28, 28, 33, 37], 'number': 2}, {'array': [0, 4, 9, 14, 14, 17, 19], 'number': 3}, {'array': [0, 5, 11, 16, 16, 23], 'number': 4}, {'array': [1, 5, 7, 11, 15, 16, 21, 25, 29, 29, 29, 30, 33], 'number': 2}, {'array': [0, 1, 10, 11, 21], 'number': 5}, {'array': [0, 4, 6, 8, 9, 10, 11], 'number': 2}, {'array': [1, 8, 14, 22, 30, 35, 42, 47, 52, 61, 66, 68], 'number': 4}, {'array': [1, 3, 7, 11, 18, 20, 28, 30, 34, 36], 'number': 4}, {'array': [0, 5, 15, 19, 30, 38, 42, 42, 45, 47], 'number': 5}, {'array': [1, 7, 14, 15, 16, 18, 25, 26, 30], 'number': 3}]"
        },
        "outputs": [
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ],
        "meta": {
            "id": 69,
            "canonical_solution": "",
            "entry_point": "hour_glass"
        }
    },
    "131": {
        "instruction": "Реализуй функцию(ии) на языке Python\n{function}",
        "inputs": {
            "function": "def selective_sum(number: int) -> int:\n    \"\"\"Найдите сумму всех чисел от 1 до number включительно таких, которые делятся на 3, 5 или 7. Выведите полученную сумму.\n    Примеры:\n       selective_sum(number=44) == 499\n       selective_sum(number=58) == 964\n    \"\"\"",
            "tests": "[{'number': 44}, {'number': 58}, {'number': 96}, {'number': 42}, {'number': 3}, {'number': 19}, {'number': 46}, {'number': 18}, {'number': 37}, {'number': 49}]"
        },
        "outputs": [
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ],
        "meta": {
            "id": 131,
            "canonical_solution": "",
            "entry_point": "selective_sum"
        }
    },
    "25": {
        "instruction": "Дано описание функции, напиши программу на языке Python\n{function}",
        "inputs": {
            "function": "from typing import List\n\n\ndef count_zeros(array: List[int]) -> int:\n    \"\"\"В массиве array посчитайте количество нулей и выведите его.\n    Примеры:\n       count_zeros(array=[3, 5, 2, 2, 7, 5]) == 0\n       count_zeros(array=[3, 0, 4, 2, 8, 4, 0]) == 2\n    \"\"\"",
            "tests": "[{'array': [3, 5, 2, 2, 7, 5]}, {'array': [3, 0, 4, 2, 8, 4, 0]}, {'array': [4, 8, 4, 0, 3, 5, 0, 6, 1, 8, 7, 9]}, {'array': [5, 3, 3, 8, 7, 2, 2, 0, 8, 0, 3]}, {'array': [8, 8, 4, 0, 2, 0, 9, 2, 6, 7, 8, 7, 9]}, {'array': [2, 0, 8, 2, 8, 9, 5, 3]}, {'array': [2, 6, 9, 8, 4, 7, 6, 0, 0, 3, 6, 0, 7]}, {'array': [4, 3, 6, 9, 4, 0, 4, 5, 4, 3, 7, 9, 6, 2]}, {'array': [4, 3, 6, 6, 0, 9, 0, 6, 8, 0, 0]}, {'array': [3, 1, 6, 7, 5, 8, 4, 7, 5, 0, 5, 6, 0, 2]}]"
        },
        "outputs": [
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ],
        "meta": {
            "id": 25,
            "canonical_solution": "",
            "entry_point": "count_zeros"
        }
    },
    "78": {
        "instruction": "Необходимо написать код по условию из строковой переменной документации, следующей после функции(ий)\n{function}",
        "inputs": {
            "function": "from typing import List\n\n\ndef diagonal_sum(matrix: List[List[int]]) -> int:\n    \"\"\"Выведите сумму всех чисел на главной и побочной диагонали квадратной матрицы matrix (тех, что не попали на главную диагональ). Главная диагональ начинается в левом верхнем элементе и идет вправо вниз по диагонали. Побочная диагональ начинается в левом нижнем углу и идет по диагонали вправо вверх.\n    Примеры:\n       diagonal_sum(matrix=[[1, 1, 4, 8, 1], [9, 7, 2, 3, 1], [7, 4, 1, 1, 9], [8, 3, 6, 4, 4], [9, 5, 2, 9, 9]]) == 38\n       diagonal_sum(matrix=[[1, 5, 6, 9, 4, 9], [6, 8, 9, 3, 4, 7], [3, 4, 7, 9, 8, 5], [9, 2, 3, 8, 9, 6], [2, 4, 8, 9, 3, 4], [6, 9, 6, 4, 8, 6]]) == 68\n    \"\"\"",
            "tests": "[{'matrix': [[1, 1, 4, 8, 1], [9, 7, 2, 3, 1], [7, 4, 1, 1, 9], [8, 3, 6, 4, 4], [9, 5, 2, 9, 9]]}, {'matrix': [[1, 5, 6, 9, 4, 9], [6, 8, 9, 3, 4, 7], [3, 4, 7, 9, 8, 5], [9, 2, 3, 8, 9, 6], [2, 4, 8, 9, 3, 4], [6, 9, 6, 4, 8, 6]]}, {'matrix': [[1, 8, 6, 4, 3], [8, 5, 9, 1, 2], [6, 2, 2, 2, 5], [3, 7, 4, 3, 9], [9, 4, 4, 2, 2]]}, {'matrix': [[6, 3, 7, 8, 5, 3], [9, 7, 8, 6, 4, 7], [4, 1, 2, 1, 6, 7], [1, 6, 5, 5, 6, 8], [8, 5, 7, 3, 7, 9], [4, 9, 8, 6, 2, 4]]}, {'matrix': [[1, 1, 2, 2], [2, 7, 8, 4], [8, 6, 2, 4], [7, 3, 1, 7]]}, {'matrix': [[6, 7, 3], [4, 8, 9], [8, 7, 6]]}, {'matrix': [[4, 7, 4, 1], [3, 3, 3, 4], [1, 6, 4, 6], [6, 1, 9, 8]]}, {'matrix': [[3, 1, 7, 3], [6, 6, 2, 6], [7, 2, 1, 2], [9, 6, 6, 9]]}, {'matrix': [[2, 9, 3, 1, 1], [9, 2, 9, 4, 1], [9, 7, 4, 2, 3], [4, 5, 8, 8, 5], [5, 3, 6, 7, 3]]}, {'matrix': [[1, 5, 7], [6, 5, 4], [2, 4, 7]]}]"
        },
        "outputs": [
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ],
        "meta": {
            "id": 78,
            "canonical_solution": "",
            "entry_point": "diagonal_sum"
        }
    },
    "110": {
        "instruction": "Реши задачу по программированию\n{function}",
        "inputs": {
            "function": "from typing import List\n\n\ndef unique_numbers(array: List[int]) -> int:\n    \"\"\"Дан список чисел array. Выведите сумму всех уникальных чисел данного массива. Уникальным является такое число, которое больше не встречается в списке.\n    Примеры:\n       unique_numbers(array=[7, 0, 2, 2, 5, 6, 5, 5, 7, 1]) == 7\n       unique_numbers(array=[5, 3, 8, 1, 5, 1, 0, 6, 6, 1, 2, 2]) == 11\n    \"\"\"",
            "tests": "[{'array': [7, 0, 2, 2, 5, 6, 5, 5, 7, 1]}, {'array': [5, 3, 8, 1, 5, 1, 0, 6, 6, 1, 2, 2]}, {'array': [8, 9, 1, 0, 3, 7, 8, 5, 0, 4, 7, 6]}, {'array': [6, 1, 2, 0, 4]}, {'array': [8, 3, 1, 3, 2, 1, 7, 8, 2, 7, 9, 0, 0]}, {'array': [6, 8, 9, 0, 0, 6, 2, 2, 4, 7, 9, 8]}, {'array': [9, 7, 8, 9, 2, 0]}, {'array': [3, 4, 2, 1, 3, 0, 9, 2, 7, 5]}, {'array': [1, 7, 8, 7, 8, 3, 9, 4, 5, 6, 7]}, {'array': [4, 6, 8, 6, 5, 7, 3, 9, 6, 9, 7]}]"
        },
        "outputs": [
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ],
        "meta": {
            "id": 110,
            "canonical_solution": "",
            "entry_point": "unique_numbers"
        }
    },
    "13": {
        "instruction": "Необходимо реализовать логику на языке Python для следующей программы\n{function}",
        "inputs": {
            "function": "def least_divider(number: int) -> int:\n    \"\"\"Выведите наименьший не равный 1 натуральный делитель числа number.\n    Примеры:\n       least_divider(number=933) == 3\n       least_divider(number=846) == 2\n    \"\"\"",
            "tests": "[{'number': 933}, {'number': 846}, {'number': 302}, {'number': 761}, {'number': 666}, {'number': 352}, {'number': 40}, {'number': 158}, {'number': 473}, {'number': 503}]"
        },
        "outputs": [
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ],
        "meta": {
            "id": 13,
            "canonical_solution": "",
            "entry_point": "least_divider"
        }
    },
    "91": {
        "instruction": "Реализуй функцию(ии) на языке Python\n{function}",
        "inputs": {
            "function": "from typing import List\n\n\ndef symmetic_difference(set1: set, set2: set) -> List[int]:\n    \"\"\"Даны два списка чисел: set1 и set2. Преобразуйте списки в множества. Выведите симметрическую разность множест в виде отсортированного по возрастанию списка. Симметрическая разность множеств – это совокупность элементов этих множеств, которые есть только в одном из них.\n    Примеры:\n       symmetic_difference(set1=[2, 3, 5, 6, 7, 8, 11], set2=[3, 4, 5, 7, 8, 9, 11]) == [2, 4, 6, 9]\n       symmetic_difference(set1=[2, 3, 4, 5, 7, 8, 10, 11], set2=[1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]) == [1, 6, 9]\n    \"\"\"",
            "tests": "[{'set1': [2, 3, 5, 6, 7, 8, 11], 'set2': [3, 4, 5, 7, 8, 9, 11]}, {'set1': [2, 3, 4, 5, 7, 8, 10, 11], 'set2': [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]}, {'set1': [1, 2, 4, 5, 7, 10, 11], 'set2': [1, 2, 3, 4, 5, 7, 8, 9, 10, 11]}, {'set1': [1, 2, 3, 4, 5, 7, 8, 10, 11], 'set2': [1, 3, 4, 6, 7, 9, 10, 11]}, {'set1': [1, 3, 4, 5, 6, 7, 8, 9, 11], 'set2': [1, 3, 4, 5, 6, 7, 8, 9, 11]}, {'set1': [1, 2, 3, 4, 6, 9, 10, 11], 'set2': [2, 3, 4, 6, 7, 8, 10, 11]}, {'set1': [1, 2, 3, 4, 7, 8, 9, 10, 11], 'set2': [1, 4, 5, 6, 8, 9, 11]}, {'set1': [1, 2, 3, 4, 6, 7, 8, 9, 10], 'set2': [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]}, {'set1': [1, 2, 5, 6, 7, 8, 9, 10, 11], 'set2': [1, 2, 3, 4, 7, 8, 9, 11]}, {'set1': [1, 2, 5, 6, 7, 9, 10], 'set2': [1, 2, 4, 7, 8, 10, 11]}]"
        },
        "outputs": [
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ],
        "meta": {
            "id": 91,
            "canonical_solution": "",
            "entry_point": "symmetic_difference"
        }
    },
    "134": {
        "instruction": "Допишите код на языке Python в соответствии с условием, приведенным в описании\n{function}",
        "inputs": {
            "function": "from typing import List\n\n\ndef count_vowels(array: List[str], number1: int, number2: int) -> int:\n    \"\"\"Выведите, сколько слов в списке array в диапазоне индексов от number1 до number2, начинаются на гласную букву и заканчиваются гласной буквой (гласные буквы: 'а', 'у', 'о', 'ы', 'и', 'э', 'я', 'ю', 'ё', 'е').\n    Примеры:\n       count_vowels(array=['Когда', 'юла', 'ему', 'она', 'случалось', 'ела', 'брать', 'меня', 'на', 'руки'], number1=3, number2=9) == 2\n       count_vowels(array=['И', 'надо', 'усердно', 'исполняли', 'они', 'свою', 'обязанность'], number1=0, number2=6) == 4\n    \"\"\"",
            "tests": "[{'array': ['Когда', 'юла', 'ему', 'она', 'случалось', 'ела', 'брать', 'меня', 'на', 'руки'], 'number1': 3, 'number2': 9}, {'array': ['И', 'надо', 'усердно', 'исполняли', 'они', 'свою', 'обязанность'], 'number1': 0, 'number2': 6}, {'array': ['на', 'дворе', 'у', 'Юры', 'у', 'него', 'или', 'никогда', 'не', 'валялось', 'ни', 'сору'], 'number1': 0, 'number2': 11}, {'array': ['И', 'омега', 'глаза', 'и', 'ура', 'отделился', 'стены'], 'number1': 1, 'number2': 6}, {'array': ['замолкла', 'и', 'вздохнула,', 'а', 'потом', 'сказала', 'нам'], 'number1': 1, 'number2': 6}, {'array': ['пожертвовав', 'и', 'не', 'мною', 'одному', 'однако', 'краснощекому', 'баварскому', 'лейтенантуБыло', 'что-то', 'свое,', 'особенное,', 'в', 'складе', 'ее', 'смугловатого,', 'круглого', 'лица'], 'number1': 4, 'number2': 17}, {'array': ['вилась', 'пряталась', 'скату', 'узкая', 'лесная', 'долина'], 'number1': 3, 'number2': 5}, {'array': ['я', 'трусы', 'горшок', 'ты', 'нет', 'да', 'или', 'вилка'], 'number1': 3, 'number2': 6}]"
        },
        "outputs": [
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ],
        "meta": {
            "id": 134,
            "canonical_solution": "",
            "entry_point": "count_vowels"
        }
    },
    "140": {
        "instruction": "Реши задачу по программированию\n{function}",
        "inputs": {
            "function": "def equal_sums(number: int) -> int:\n    \"\"\"Для целого числа number определите такое центральное число, что сумма всех чисел от 1 до центрального включительно равна сумме всех чисел от центрального числа до числа number включительно. Выведите полученное число. Если такого числа нет, то выведите -1.\n    Примеры:\n       equal_sums(number=1) == 1\n       equal_sums(number=192) == -1\n    \"\"\"",
            "tests": "[{'number': 1}, {'number': 192}, {'number': 843}, {'number': 1230}, {'number': 49}, {'number': 8763}, {'number': 8}, {'number': 219}, {'number': 288}, {'number': 4979}]"
        },
        "outputs": [
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ],
        "meta": {
            "id": 140,
            "canonical_solution": "",
            "entry_point": "equal_sums"
        }
    },
    "36": {
        "instruction": "На вход подается функция(ии) с описанием в виде строки docstring. В соответствии с описанием вам необходимо реализовать функцию(ии)\n{function}",
        "inputs": {
            "function": "from typing import List\n\n\ndef count_combinations(array: List[int]) -> int:\n    \"\"\"Вам дан массив array из длин отрезков. Сколько есть способов выбрать из данного массива три элемента, из которых получится невырожденный треугольник? Невырожденным является треугольник, у которого всегда одна сторона меньше суммы двух других. Гарантируется, что массив array содержит от 3 до 20 чисел. Выведите получившееся число.\n    Примеры:\n       count_combinations(array=[5, 4, 1, 5, 1, 6, 4, 9, 6, 6, 8]) == 88\n       count_combinations(array=[1, 1, 6, 6, 7, 3]) == 6\n    \"\"\"",
            "tests": "[{'array': [5, 4, 1, 5, 1, 6, 4, 9, 6, 6, 8]}, {'array': [1, 1, 6, 6, 7, 3]}, {'array': [6, 2, 2, 9, 7, 8, 6, 7, 4, 5, 7]}, {'array': [5, 7, 3, 4, 3, 7]}, {'array': [7, 7, 4, 9, 2, 2, 2, 9, 4, 7, 7, 5, 2]}, {'array': [6, 9, 1, 7, 6, 2, 3, 7]}, {'array': [5, 9, 6, 6, 6]}, {'array': [9, 1, 1, 8, 1, 7, 4, 4, 6, 4, 4, 8, 5, 4]}, {'array': [3, 8, 8, 1, 5, 4, 1, 1]}, {'array': [6, 8, 9, 1, 1, 9, 9]}]"
        },
        "outputs": [
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ],
        "meta": {
            "id": 36,
            "canonical_solution": "",
            "entry_point": "count_combinations"
        }
    },
    "60": {
        "instruction": "Реши задачу по программированию\n{function}",
        "inputs": {
            "function": "def hex_sum(A: int, B: int) -> str:\n    \"\"\"Вам даны два числа в двоичной системе исчисления: A и B. Сложите данные числа и выведите результат сложения в шестнадцатиричной системе исчисления в виде строки.\n    Примеры:\n       hex_sum(A=1010, B=11100) == '26'\n       hex_sum(A=110010, B=10001001) == 'bb'\n    \"\"\"",
            "tests": "[{'A': 1010, 'B': 11100}, {'A': 110010, 'B': 10001001}, {'A': 1001010, 'B': 10111000100010}, {'A': 1111010010, 'B': 10}, {'A': 11110111101, 'B': 1011011110}, {'A': 11101000, 'B': 111}, {'A': 110001, 'B': 11100}, {'A': 1, 'B': 11010100110110}, {'A': 101, 'B': 11001001100}, {'A': 10110111, 'B': 1100101}]"
        },
        "outputs": [
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ],
        "meta": {
            "id": 60,
            "canonical_solution": "",
            "entry_point": "hex_sum"
        }
    },
    "92": {
        "instruction": "Напишите программу по строке документации\n{function}",
        "inputs": {
            "function": "from typing import List\n\n\ndef set_complement(set1: set, set2: set) -> List[int]:\n    \"\"\"Даны два списка чисел: set1 и set2. Преобразуйте списки в множества. Выведите дополнение set1 до set2 в виде отсортированного по возрастанию списка. Дополнением множества до другого множества являются элементы, которые есть во втором множестве и нет в первом.\n    Примеры:\n       set_complement(set1=[2, 3, 4, 5, 6, 7, 8, 9, 10, 11], set2=[1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]) == [1]\n       set_complement(set1=[2, 3, 6, 7, 8, 9, 10, 11], set2=[1, 2, 3, 4, 7, 9, 10, 11]) == [1, 4]\n    \"\"\"",
            "tests": "[{'set1': [2, 3, 4, 5, 6, 7, 8, 9, 10, 11], 'set2': [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]}, {'set1': [2, 3, 6, 7, 8, 9, 10, 11], 'set2': [1, 2, 3, 4, 7, 9, 10, 11]}, {'set1': [1, 2, 4, 5, 6, 7, 8, 9, 10, 11], 'set2': [1, 2, 4, 5, 6, 9, 11]}, {'set1': [1, 2, 4, 5, 6, 7, 8, 9, 11], 'set2': [1, 2, 3, 4, 5, 7, 8, 9, 10]}, {'set1': [1, 3, 4, 5, 6, 7, 10, 11], 'set2': [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]}, {'set1': [1, 5, 6, 7, 8, 10, 11], 'set2': [1, 4, 5, 6, 7, 9]}, {'set1': [2, 6, 7, 9, 11], 'set2': [2, 3, 5, 6, 7, 9, 10, 11]}, {'set1': [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11], 'set2': [1, 2, 4, 6, 7, 8, 9]}, {'set1': [1, 2, 3, 6, 7, 8, 9, 10], 'set2': [4, 5, 6, 7, 8, 9, 10, 11]}, {'set1': [1, 2, 3, 4, 5, 6, 7, 8, 9, 11], 'set2': [2, 4, 6, 7, 8]}]"
        },
        "outputs": [
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ],
        "meta": {
            "id": 92,
            "canonical_solution": "",
            "entry_point": "set_complement"
        }
    },
    "27": {
        "instruction": "По данному условию с фиксированной шапкой функции(ий) напиши программу\n{function}",
        "inputs": {
            "function": "from typing import List\n\n\ndef odd_maximum(array: List[int]) -> int:\n    \"\"\"Среди всех чисел в списке array найдите наибольшее нечетное число и выведите его. Если такого числа нет, выведите \"-1\".\n    Примеры:\n       odd_maximum(array=[87, 11, 74, 33, 94, 52]) == 87\n       odd_maximum(array=[17, 7, 78, 36, 64]) == 17\n    \"\"\"",
            "tests": "[{'array': [87, 11, 74, 33, 94, 52]}, {'array': [17, 7, 78, 36, 64]}, {'array': [11, 92, 67, 47, 34, 77, 42, 49, 17, 13, 89, 2, 27]}, {'array': [33, 34, 36, 1, 67, 32, 72, 95, 1, 43, 52, 42]}, {'array': [24, 64, 60, 46, 62]}, {'array': [72, 7, 62, 5, 90, 13, 12, 92, 32]}, {'array': [53, 43, 69, 88, 22]}, {'array': [30, 50, 41, 44, 55, 22, 39, 43, 44, 84, 51]}, {'array': [39, 29, 70, 5, 93, 1, 2]}, {'array': [85, 11, 89, 83, 15, 68, 53, 90, 26]}]"
        },
        "outputs": [
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ],
        "meta": {
            "id": 27,
            "canonical_solution": "",
            "entry_point": "odd_maximum"
        }
    },
    "120": {
        "instruction": "Реши задачу по программированию\n{function}",
        "inputs": {
            "function": "def minimum_inversions(number: int, target: int) -> int:\n    \"\"\"Выведите, какое наименьшее количество инверсий битов числа number нужно сделать, чтобы получилось число target. Инверсия битов – это замена \"0\" на \"1\" и \"1\" на \"0\" в двоичной записи числа. Инвертировать можно как биты после первого значащего бита, так и до него.\n    Примеры:\n       minimum_inversions(number=469, target=380) == 4\n       minimum_inversions(number=17, target=253) == 5\n    \"\"\"",
            "tests": "[{'number': 469, 'target': 380}, {'number': 17, 'target': 253}, {'number': 290, 'target': 102}, {'number': 348, 'target': 128}, {'number': 372, 'target': 375}, {'number': 463, 'target': 376}, {'number': 326, 'target': 137}, {'number': 97, 'target': 81}, {'number': 485, 'target': 270}, {'number': 112, 'target': 348}]"
        },
        "outputs": [
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ],
        "meta": {
            "id": 120,
            "canonical_solution": "",
            "entry_point": "minimum_inversions"
        }
    },
    "74": {
        "instruction": "Допишите код на языке Python в соответствии с условием, приведенным в описании\n{function}",
        "inputs": {
            "function": "def cyclic_shift(string: str, target: str) -> str:\n    \"\"\"Если строка string может стать равной строке target после конечного числа циклических сдвигов влево всех символов строки string, то выведите \"Да\". Иначе, выведите \"Нет\". Циклический сдвиг влево экивалентен тому, что у каждого элемента массива, кроме первого, из индекса вычитается единица, а индекс первого элемента становится равным индексу последнего элемента.\n    Примеры:\n       cyclic_shift(string=аои, target=оиа) == 'Да'\n       cyclic_shift(string=омчшалш, target=лэвыеейэ) == 'Нет'\n    \"\"\"",
            "tests": "[{'string': 'аои', 'target': 'оиа'}, {'string': 'омчшалш', 'target': 'лэвыеейэ'}, {'string': 'ыпоиеыева', 'target': 'еыеваыпои'}, {'string': 'вммой', 'target': 'ымэд'}, {'string': 'рвилгхй', 'target': 'оуяэич'}, {'string': 'ыукдлмьмапбо', 'target': 'апбоыукдлмьм'}, {'string': 'хос', 'target': 'осх'}, {'string': 'хюу', 'target': 'ухю'}, {'string': 'фыпмыдщфшкрпк', 'target': 'щфшккфыпмыд'}, {'string': 'нуи', 'target': 'уин'}]"
        },
        "outputs": [
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ],
        "meta": {
            "id": 74,
            "canonical_solution": "",
            "entry_point": "cyclic_shift"
        }
    },
    "51": {
        "instruction": "Реализуй функцию(ии) на языке Python\n{function}",
        "inputs": {
            "function": "def are_coprime(A: int, B: int) -> str:\n    \"\"\"Определите, являются ли целые положительные числа A и B взаимно простыми? Взаимно простые числа не имеют общих делителей кроме 1. Если являются, выведите \"Да\", иначе выведите \"Нет\".\n    Примеры:\n       are_coprime(A=33, B=3) == 'Нет'\n       are_coprime(A=25, B=2) == 'Да'\n    \"\"\"",
            "tests": "[{'A': 33, 'B': 3}, {'A': 25, 'B': 2}, {'A': 4, 'B': 6}, {'A': 253, 'B': 254}, {'A': 1, 'B': 0}, {'A': 255, 'B': 65535}, {'A': 54475474574, 'B': 9876342156547}, {'A': 144, 'B': 4}, {'A': 44, 'B': 44}, {'A': 45, 'B': 22}]"
        },
        "outputs": [
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ],
        "meta": {
            "id": 51,
            "canonical_solution": "",
            "entry_point": "are_coprime"
        }
    },
    "136": {
        "instruction": "На вход подается функция(ии) с описанием в виде строки docstring. В соответствии с описанием вам необходимо реализовать функцию(ии)\n{function}",
        "inputs": {
            "function": "from typing import List\n\n\ndef split_array(array: List[int]) -> List[int]:\n    \"\"\"В целочисленном массиве array разделите все числа на отдельные цифры, сохранив изначальный порядок и выведите их все одним списком. Если на вход пришел пустой массив, выведите пустой массив.\n    Примеры:\n       split_array(array=[75, 4, 65, 45, 31, 86, 35, 63, 13, 23, 3]) == [7, 5, 4, 6, 5, 4, 5, 3, 1, 8, 6, 3, 5, 6, 3, 1, 3, 2, 3, 3]\n       split_array(array=[33, 47, 68, 73, 89, 69, 37, 25, 84, 49, 16, 4, 76]) == [3, 3, 4, 7, 6, 8, 7, 3, 8, 9, 6, 9, 3, 7, 2, 5, 8, 4, 4, 9, 1, 6, 4, 7, 6]\n    \"\"\"",
            "tests": "[{'array': [75, 4, 65, 45, 31, 86, 35, 63, 13, 23, 3]}, {'array': [33, 47, 68, 73, 89, 69, 37, 25, 84, 49, 16, 4, 76]}, {'array': [69, 86, 94, 87, 90, 26, 99, 99, 69, 16, 93, 91, 67]}, {'array': [55, 38, 16, 37, 12, 80, 43, 49, 37, 5, 27, 82]}, {'array': [84, 3, 91, 55, 72, 26, 95, 48, 48, 7]}, {'array': [56, 0, 94, 10, 53, 6, 26, 16, 33, 4, 46]}, {'array': [24, 53, 63, 98, 9, 0, 1, 59, 12, 88, 56, 37, 14, 66]}, {'array': [68, 39, 17, 82, 74, 22, 51, 22, 36, 93, 73]}, {'array': []}, {'array': [77, 88, 8, 38, 59, 1, 53, 84, 83, 15, 5, 19, 22]}]"
        },
        "outputs": [
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ],
        "meta": {
            "id": 136,
            "canonical_solution": "",
            "entry_point": "split_array"
        }
    },
    "4": {
        "instruction": "Допишите код на языке Python в соответствии с условием, приведенным в описании\n{function}",
        "inputs": {
            "function": "def count_steps(required: int, forward_step: int, backward_step:int) -> int:\n    \"\"\"Шкала прогресса за один шаг заполняется на forward_step процентов, а затем сразу убывает на backward_step процентов. Выведите, за сколько шагов на шкале прогресса будет достигнута отметка required процентов, если известно, что forward_step > backward_step.\n    Примеры:\n       count_steps(required=100, forward_step=6, backward_step=5) == 95\n       count_steps(required=90, forward_step=20, backward_step=12) == 10\n    \"\"\"",
            "tests": "[{'required': 100, 'forward_step': 6, 'backward_step': 5}, {'required': 90, 'forward_step': 20, 'backward_step': 12}, {'required': 85, 'forward_step': 5, 'backward_step': 1}, {'required': 80, 'forward_step': 53, 'backward_step': 52}, {'required': 70, 'forward_step': 9, 'backward_step': 8}, {'required': 60, 'forward_step': 50, 'backward_step': 7}, {'required': 50, 'forward_step': 22, 'backward_step': 6}, {'required': 25, 'forward_step': 11, 'backward_step': 5}, {'required': 10, 'forward_step': 13, 'backward_step': 2}, {'required': 5, 'forward_step': 2, 'backward_step': 1}]"
        },
        "outputs": [
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ],
        "meta": {
            "id": 4,
            "canonical_solution": "",
            "entry_point": "count_steps"
        }
    },
    "96": {
        "instruction": "На вход подается функция(ии) с описанием в виде строки docstring. В соответствии с описанием вам необходимо реализовать функцию(ии)\n{function}",
        "inputs": {
            "function": "def alphabet_encoding(number: int, string: str) -> int:\n    \"\"\"Дана строка string и натуральное число number. Замените в string все буквы на их порядковые номера в русском алфавите. Для получившегося числа преобразуйте его в сумму его цифр number раз. Выведите получившееся число в целочисленном виде.\n    Примеры:\n       alphabet_encoding(string=флюгегехаймен, number=4) == 6\n       alphabet_encoding(string=метафора, number=3) == 3\n    \"\"\"",
            "tests": "[{'string': 'флюгегехаймен', 'number': 4}, {'string': 'метафора', 'number': 3}, {'string': 'йсучиюывдум', 'number': 3}, {'string': 'щбфсхяясйгыгнгнфщщ', 'number': 3}, {'string': 'удлшмдуыхшьхмъйвцяьрзятфъшыфднйу', 'number': 3}, {'string': 'еяиичсняхпщссюниьдвахыф', 'number': 3}, {'string': 'фююейяысачхвкяфйфгъфлбчпнмкю', 'number': 3}, {'string': 'вюччцлшаевюасхлйюьбсжмч', 'number': 1}, {'string': 'кпкдйбняомбфьчябмыэвхдйдрбэфэрзмдч', 'number': 4}, {'string': 'аршэядцепйцнчфытъкщщщпхъдр', 'number': 3}]"
        },
        "outputs": [
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ],
        "meta": {
            "id": 96,
            "canonical_solution": "",
            "entry_point": "alphabet_encoding"
        }
    },
    "150": {
        "instruction": "Реши задачу по программированию\n{function}",
        "inputs": {
            "function": "from typing import List\n\n\ndef topk_elements(array: List[str], number: int) -> List[str]:\n    \"\"\"Выведите number наиболее часто встречающихся элементов списка array в порядке убывания по частоте появления в списке и в лексикографическом порядке для элементов с одинаковой частотой. Гарантируется, что array не пуст, а number не меньше 1.\n    Примеры:\n       topk_elements(array=['Калан', 'Изгнать', 'Изгнать', 'Изгнать', 'Изгнать', 'Словесник', 'Словесник', 'Словесник', 'Диссонанс', 'Диссонанс', 'Диссонанс'], number=2) == ['Изгнать', 'Диссонанс']\n       topk_elements(array=['Случай', 'Вправить', 'Калан', 'Калан', 'Аут', 'Аут', 'Жаловаться'], number=4) == ['Аут', 'Калан', 'Вправить', 'Жаловаться']\n    \"\"\"",
            "tests": "[{'array': ['Калан', 'Изгнать', 'Изгнать', 'Изгнать', 'Изгнать', 'Словесник', 'Словесник', 'Словесник', 'Диссонанс', 'Диссонанс', 'Диссонанс'], 'number': 2}, {'array': ['Случай', 'Вправить', 'Калан', 'Калан', 'Аут', 'Аут', 'Жаловаться'], 'number': 4}, {'array': ['Тюркология', 'Тюркология', 'Тюркология', 'Изборник', 'Изборник', 'Изборник', 'Столешница', 'Столешница', 'Столешница', 'Столешница', 'Девиация', 'Девиация', 'Дублон', 'Дублон'], 'number': 2}, {'array': ['Клоун', 'Клоун', 'Клоун', 'Втесаться', 'Метать', 'Метать', 'Метать', 'Метать', 'Пересолить', 'Пересолить', 'Пересолить', 'Пересолить', 'Подержание', 'Подержание', 'Подержание', 'Задник'], 'number': 1}, {'array': ['Калан', 'Калан', 'Калан', 'Привернуть', 'Привернуть', 'Изгнать', 'Изгнать'], 'number': 2}, {'array': ['Веко', 'Изгнать', 'Изгнать', 'Диссонанс', 'Диссонанс', 'Диссонанс'], 'number': 1}, {'array': ['Подержание', 'Подержание', 'Череп', 'Череп', 'Метать', 'Привернуть', 'Изгнать', 'Изгнать', 'Диссонанс', 'Диссонанс'], 'number': 2}, {'array': ['Задник', 'Задник', 'Работаться', 'Работаться', 'Девиация', 'Девиация', 'Девиация', 'Девиация', 'Изборник', 'Изборник', 'Изборник', 'Жим', 'Жим', 'Жим'], 'number': 1}, {'array': ['Жим', 'Вправить', 'Случай'], 'number': 2}, {'array': ['Задник', 'Задник', 'Задник', 'Задник', 'Порскать', 'Дублон', 'Втесаться', 'Втесаться'], 'number': 2}]"
        },
        "outputs": [
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ],
        "meta": {
            "id": 150,
            "canonical_solution": "",
            "entry_point": "topk_elements"
        }
    },
    "41": {
        "instruction": "Реализуй функцию(ии) на языке Python\n{function}",
        "inputs": {
            "function": "def find_maximum(A: int, B: int) -> int:\n    \"\"\"Даны два целых числа A и B. Если первое число больше второго, выведите число 1, иначе выведите число 2. Если число A равно числу B, то вывести нужно число 2.\n    Примеры:\n       find_maximum(A=33, B=3) == 1\n       find_maximum(A=25, B=2) == 1\n    \"\"\"",
            "tests": "[{'A': 33, 'B': 3}, {'A': 25, 'B': 2}, {'A': 4, 'B': 6}, {'A': 253, 'B': 254}, {'A': 1, 'B': 0}, {'A': 255, 'B': 65535}, {'A': 54475474574, 'B': 9876342156547}, {'A': 144, 'B': 4}, {'A': 44, 'B': 44}, {'A': 45, 'B': 22}]"
        },
        "outputs": [
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ],
        "meta": {
            "id": 41,
            "canonical_solution": "",
            "entry_point": "find_maximum"
        }
    },
    "162": {
        "instruction": "Напишите программу по строке документации\n{function}",
        "inputs": {
            "function": "def truncate_string(string: str) -> int:\n    \"\"\"Дана строка string, в которой только 3 уникальных символа. Вам разрешается одновременно удалять символы из начала и конца строки при условии, что они одинаковы. Проведите все возможные удаления и выведите длину оставшейся строки.\n    Примеры:\n       truncate_string(string=аааааааааа) == 0\n       truncate_string(string=абвабвабв) == 9\n    \"\"\"",
            "tests": "[{'string': 'аааааааааа'}, {'string': 'абвабвабв'}, {'string': 'аааагггг'}, {'string': 'даббадд'}, {'string': ''}, {'string': 'еже'}, {'string': 'келек'}, {'string': 'ахаххапхаха'}, {'string': 'узи'}, {'string': 'выпвыпвып'}]"
        },
        "outputs": [
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ],
        "meta": {
            "id": 162,
            "canonical_solution": "",
            "entry_point": "truncate_string"
        }
    },
    "133": {
        "instruction": "Необходимо реализовать логику на языке Python для следующей программы\n{function}",
        "inputs": {
            "function": "def parity_sum(number: int) -> int:\n    \"\"\"Дано десятичное натуральное число number. Выведите сумму количества единиц в двоичной записи number с четными индексами и количества единиц в двоичной записи number с нечетными индексами.\n    Примеры:\n       parity_sum(number=4) == 1\n       parity_sum(number=192) == 2\n    \"\"\"",
            "tests": "[{'number': 4}, {'number': 192}, {'number': 843}, {'number': 1230}, {'number': 273}, {'number': 876543}, {'number': 10}, {'number': 219}, {'number': 327}, {'number': 49729}]"
        },
        "outputs": [
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ],
        "meta": {
            "id": 133,
            "canonical_solution": "",
            "entry_point": "parity_sum"
        }
    },
    "101": {
        "instruction": "Реализуй функцию(ии) на языке Python\n{function}",
        "inputs": {
            "function": "def index_sort(string: str) -> str:\n    \"\"\"В строке string все слова разделены пробелом. В конце каждого слова содержится его индекс – порядковый номер в некотором предложении (индексы начинаются с 1). Отсортируйте слова в строке string в порядке возрастания индекса и после этого удалите индексы в конце слова. Выведите получившуюся строку предложения.\n    Примеры:\n       index_sort(string=Аппетит1 приходит2 во3 время4 еды5) == 'Аппетит приходит во время еды'\n       index_sort(string=Без1 труда2 не3 выловишь3 и4 рыбку5 из6 пруда,7 не8 то,9 что10 сапог11) == 'Без труда не выловишь и рыбку из пруда, не то, что сапог'\n    \"\"\"",
            "tests": "[{'string': 'Аппетит1 приходит2 во3 время4 еды5'}, {'string': 'Без1 труда2 не3 выловишь3 и4 рыбку5 из6 пруда,7 не8 то,9 что10 сапог11'}, {'string': 'Волков1 бояться2 –3 в4 лес5 не6 ходить7'}, {'string': 'Бедность1 не2 порок3'}, {'string': 'Готовь1 сани2 летом,3 а4 телегу5 зимой6'}, {'string': 'В1 здоровом2 теле3 –4 здоровый5 дух6'}, {'string': 'Дарёному1 коню2 в3 зубы4 не5 смотрят6'}, {'string': 'Бесплатный1 сыр,2 бывает-3 только4 в5 мышеловке6'}, {'string': 'Глаза1 боятся,2 а3 руки4 делают5'}, {'string': 'Бог1 шельму=2 метит3'}]"
        },
        "outputs": [
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ],
        "meta": {
            "id": 101,
            "canonical_solution": "",
            "entry_point": "index_sort"
        }
    },
    "94": {
        "instruction": "Допишите код на языке Python в соответствии с условием, приведенным в описании\n{function}",
        "inputs": {
            "function": "from typing import List\n\n\ndef prefix_string(string: str, array: List[str]) -> str:\n    \"\"\"Дана непустая строка string и непустой список строк array. Определите, является ли строка префиксом списка. Строка называется префиксом списка, если строка в точности равна конкатенации первых N слов из списка. Выведите \"Да\", если является, и \"Нет\", если не является.\n    Примеры:\n       prefix_string(string=флюгегехаймен, array=['флю', 'гег', 'еха', 'ймен', 'питон']) == 'Да'\n       prefix_string(string=программирование, array=['про', 'грам', 'иро', 'вание', 'на', 'си']) == 'Нет'\n    \"\"\"",
            "tests": "[{'string': 'флюгегехаймен', 'array': ['флю', 'гег', 'еха', 'ймен', 'питон']}, {'string': 'программирование', 'array': ['про', 'грам', 'иро', 'вание', 'на', 'си']}, {'string': 'метафора', 'array': ['ме', 'тафо', 'ра', 'текста', 'в', 'тексте']}, {'string': 'кяшвеэзюимдчжтущсъфлаойбрцхныпьг', 'array': ['кяш', 'веэзю', 'им', 'дчжтущс', 'ъфла', 'ойбрц', 'хнып', 'ьг']}, {'string': 'мъчузцквюхепяьжсдлфрышщгонабтийэ', 'array': ['мъчу', 'зцквюх', 'еп', 'яьжсдлфрышщгон', 'абтийэ']}, {'string': 'фгпэытиьежйлоюамбквзцхущшрч', 'array': ['фгпнъдсяэытиьежйлоюамбквзцхущшрч']}, {'string': 'смлыгрхцпнвщдъошеяьжфэйбюкачзути', 'array': ['смлыгр', 'хцпнвщдъош', 'еяьжфэйбюка', 'чзути', 'кек']}, {'string': 'чьщсяэшмдзхежпюфтгцоива', 'array': ['чьщыб', 'сяэшмдйлз', 'хежпнък', 'юфтгцру', 'оива']}, {'string': 'кшфйцодутмьвюяхечщрзлнсыиэбъгжпа', 'array': ['кшф', 'йцоду', 'тмьвю', 'яхечщ', 'рзлнсыиэбъ', 'гжпа', 'гойдф', 'атом']}, {'string': 'йшоярыгавниъзфбжкдхпьэм', 'array': ['йшоеяры', 'ющгавнисцт', 'ъзфбжкдул', 'хпьчэм', 'вфылорп', 'ыровиа']}]"
        },
        "outputs": [
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ],
        "meta": {
            "id": 94,
            "canonical_solution": "",
            "entry_point": "prefix_string"
        }
    },
    "147": {
        "instruction": "По данному условию с фиксированной шапкой функции(ий) напиши программу\n{function}",
        "inputs": {
            "function": "def reverse_number(number: int) -> int:\n    \"\"\"Выведите цифры числа number в обратном порядке. Если число отрицательное, то сохраните отрицательный знак в начале числа.\n    Примеры:\n       reverse_number(number=71) == 17\n       reverse_number(number=-68) == -86\n    \"\"\"",
            "tests": "[{'number': 71}, {'number': -68}, {'number': 0}, {'number': 36}, {'number': -41}, {'number': 85}, {'number': 22}, {'number': -56}, {'number': -26}, {'number': -69}]"
        },
        "outputs": [
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ],
        "meta": {
            "id": 147,
            "canonical_solution": "",
            "entry_point": "reverse_number"
        }
    },
    "89": {
        "instruction": "Дан шаблон функции(ий) с описанием работы этой функции в качестве условия задачи. Допишите программу\n{function}",
        "inputs": {
            "function": "from typing import List\n\n\ndef parity_sort(array: List[int]) -> List[int]:\n    \"\"\"Перенесите все четные элементы списка array в его начало, отсортировав их в порядке возрастания. В конце списка должны идти его нечетные элементы также в порядке возрастания. Выведите полученный список.\n    Примеры:\n       parity_sort(array=[21, 93, 25, 24, 68, 22, 42, 52, 42, 48, 94, 85, 36]) == [22, 24, 36, 42, 42, 48, 52, 68, 94, 21, 25, 85, 93]\n       parity_sort(array=[79, 66, 65, 28, 53, 72, 86, 25, 64, 59, 50, 41, 54]) == [28, 50, 54, 64, 66, 72, 86, 25, 41, 53, 59, 65, 79]\n    \"\"\"",
            "tests": "[{'array': [21, 93, 25, 24, 68, 22, 42, 52, 42, 48, 94, 85, 36]}, {'array': [79, 66, 65, 28, 53, 72, 86, 25, 64, 59, 50, 41, 54]}, {'array': [89, 97, 62, 28, 94]}, {'array': [2, 28, 56, 89, 51, 96]}, {'array': [45, 39, 16, 13, 1, 54, 28, 69, 96, 1, 1, 13, 23, 55]}, {'array': [8, 32, 32, 56, 9, 85, 91, 77, 93]}, {'array': [59, 94, 6, 19, 3, 35, 24, 95, 4]}, {'array': [51, 26, 46, 82, 34, 84, 43, 67, 78, 96, 76, 54, 56, 81]}, {'array': [43, 81, 36, 16, 79, 19, 42, 77, 8, 45, 8, 19]}, {'array': [98, 65, 37, 93, 6, 32]}]"
        },
        "outputs": [
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ],
        "meta": {
            "id": 89,
            "canonical_solution": "",
            "entry_point": "parity_sort"
        }
    },
    "31": {
        "instruction": "Реализуй функцию(ии) на языке Python\n{function}",
        "inputs": {
            "function": "from typing import List\n\n\ndef array_xor(arrayA: List[int], arrayB: List[int]) -> List[int]:\n    \"\"\"Выполните поэлементное сложение по модулю два двух непустых массивов одинаковой длины из нулей и единиц: arrayA и arrayB. В сложении по модулю два ноль получается из пар (0, 0) и (1, 1). В остальных случаях получается единица. Выведите получившийся массив.\n    Примеры:\n       array_xor(arrayA=[1, 1, 1, 0, 1, 1, 1, 1], arrayB=[1, 1, 0, 0, 1, 0, 0, 0]) == [0, 0, 1, 0, 0, 1, 1, 1]\n       array_xor(arrayA=[0, 0, 1, 0, 1, 1, 1], arrayB=[1, 1, 0, 0, 1, 1, 1]) == [1, 1, 1, 0, 0, 0, 0]\n    \"\"\"",
            "tests": "[{'arrayA': [1, 1, 1, 0, 1, 1, 1, 1], 'arrayB': [1, 1, 0, 0, 1, 0, 0, 0]}, {'arrayA': [0, 0, 1, 0, 1, 1, 1], 'arrayB': [1, 1, 0, 0, 1, 1, 1]}, {'arrayA': [0, 1, 0], 'arrayB': [0, 1, 0]}, {'arrayA': [0, 0], 'arrayB': [0, 1]}, {'arrayA': [0, 0, 1, 1, 1, 0, 1, 1, 0], 'arrayB': [1, 1, 1, 0, 1, 0, 0, 0, 0]}, {'arrayA': [0, 0, 1, 1, 0, 0, 1, 1, 1, 1, 1, 1, 0], 'arrayB': [0, 0, 1, 1, 1, 1, 0, 1, 1, 0, 1, 1, 1]}, {'arrayA': [0, 1], 'arrayB': [0, 1]}, {'arrayA': [1, 0, 0, 0, 1, 1, 0, 1], 'arrayB': [1, 0, 0, 1, 0, 1, 1, 1]}, {'arrayA': [1, 0, 0, 1, 0, 0, 1, 1, 1, 1, 0, 1, 1, 1, 0, 1], 'arrayB': [0, 0, 1, 1, 1, 0, 0, 0, 1, 1, 1, 1, 0, 0, 0, 0]}, {'arrayA': [0, 1, 1, 0, 1], 'arrayB': [0, 1, 0, 1, 0]}]"
        },
        "outputs": [
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ],
        "meta": {
            "id": 31,
            "canonical_solution": "",
            "entry_point": "array_xor"
        }
    },
    "116": {
        "instruction": "На вход подается функция(ии) с описанием в виде строки docstring. В соответствии с описанием вам необходимо реализовать функцию(ии)\n{function}",
        "inputs": {
            "function": "def common_divisors(number1: int, number2: int) -> int:\n    \"\"\"Выведите количество общих делителей чисел number1 и number2. Число A является делителем числа B, если B делится на A без остатка.\n    Примеры:\n       common_divisors(number1=63, number2=270) == 3\n       common_divisors(number1=27, number2=93) == 2\n    \"\"\"",
            "tests": "[{'number1': 63, 'number2': 270}, {'number1': 27, 'number2': 93}, {'number1': 271, 'number2': 416}, {'number1': 138, 'number2': 155}, {'number1': 394, 'number2': 35}, {'number1': 111, 'number2': 189}, {'number1': 372, 'number2': 87}, {'number1': 53, 'number2': 381}, {'number1': 81, 'number2': 227}, {'number1': 354, 'number2': 398}]"
        },
        "outputs": [
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ],
        "meta": {
            "id": 116,
            "canonical_solution": "",
            "entry_point": "common_divisors"
        }
    },
    "21": {
        "instruction": "Реализуй функцию(ии) на языке Python\n{function}",
        "inputs": {
            "function": "def quadratic_equation(A: int, B: int, C: int) -> str:\n    \"\"\"Даны коэффициенты квадратного трехчлена: A, B, C. Коэффициенты всегда являются целыми числами. Определите, есть ли у квадратного уравнения Ax ** 2 + Bx + C = 0 хотя бы одно решение. Если есть, выведите \"Да\", иначе выведите \"Нет\".\n    Примеры:\n       quadratic_equation(A=3, B=-3, C=2) == 'Нет'\n       quadratic_equation(A=0, B=-1, C=3) == 'Да'\n    \"\"\"",
            "tests": "[{'A': 3, 'B': -3, 'C': 2}, {'A': 0, 'B': -1, 'C': 3}, {'A': 1, 'B': 0, 'C': 1}, {'A': -33, 'B': 66, 'C': 222}, {'A': 22, 'B': 13, 'C': 3}, {'A': 2, 'B': 3, 'C': 5}, {'A': -3, 'B': -3, 'C': 1}, {'A': 3, 'B': 5, 'C': 7}, {'A': -2, 'B': -1, 'C': -5}, {'A': -3003, 'B': 505, 'C': 222}]"
        },
        "outputs": [
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ],
        "meta": {
            "id": 21,
            "canonical_solution": "",
            "entry_point": "quadratic_equation"
        }
    },
    "122": {
        "instruction": "Напишите программу по строке документации\n{function}",
        "inputs": {
            "function": "def capitalize_title(string: str) -> str:\n    \"\"\"Дана строка string, которая содержит несколько слов, разделенных пробелами. Все слова с длиной от 1 до 2 сделайте строчными буквами, а для остальных слов сделайте первую букву слова прописной, а остальные строчными. Выведите получившуюся строку.\n    Примеры:\n       capitalize_title(string=аппетит приходит во время еды и) == 'Аппетит Приходит во Время Еды и'\n       capitalize_title(string=бедность не порок) == 'Бедность не Порок'\n    \"\"\"",
            "tests": "[{'string': 'аппетит приходит во время еды и'}, {'string': 'бедность не порок'}, {'string': 'без труда не выловишь и рыбку из пруда'}, {'string': 'бесплатный сыр, бывает- только в мышеловке'}, {'string': 'бог шельму= метит'}, {'string': 'в здоровом теле – здоровый дух'}, {'string': 'волков бояться – в лес не ходить'}, {'string': 'глаза боятся, а руки делают'}, {'string': 'готовь сани летом, а телегу зимой'}, {'string': 'дарёному коню в зубы не смотрят'}]"
        },
        "outputs": [
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ],
        "meta": {
            "id": 122,
            "canonical_solution": "",
            "entry_point": "capitalize_title"
        }
    },
    "9": {
        "instruction": "Дан шаблон функции(ий) с описанием работы этой функции в качестве условия задачи. Допишите программу\n{function}",
        "inputs": {
            "function": "def place_inside(lengthA: int, widthA: int, heightA: int, lengthB: int, widthB: int, heightB: int) -> str:\n    \"\"\"На основании длины lengthA, ширины widthA и высоты heightA первой коробки и длины lengthB, ширины widthB и высоты heightB второй коробки определите, можно ли поместить одну из данных коробок в другую. Поворачивать коробки можно только вокруг их ребер под прямыми углами. Если можно, выведите \"Да\", иначе – \"Нет\".\n    Примеры:\n       place_inside(lengthA=3, widthA=1, heightA=5, lengthB=88, widthB=1, heightB=4) == 'Да'\n       place_inside(lengthA=3, widthA=5, heightA=7, lengthB=9, widthB=10, heightB=11) == 'Да'\n    \"\"\"",
            "tests": "[{'lengthA': 3, 'widthA': 1, 'heightA': 5, 'lengthB': 88, 'widthB': 1, 'heightB': 4}, {'lengthA': 3, 'widthA': 5, 'heightA': 7, 'lengthB': 9, 'widthB': 10, 'heightB': 11}, {'lengthA': 0, 'widthA': 0, 'heightA': 0, 'lengthB': 8, 'widthB': 1, 'heightB': 40}, {'lengthA': 3, 'widthA': 2, 'heightA': 5, 'lengthB': 0, 'widthB': 0, 'heightB': 0}, {'lengthA': 20, 'widthA': 20, 'heightA': 20, 'lengthB': 20, 'widthB': 20, 'heightB': 20}, {'lengthA': 19, 'widthA': 20, 'heightA': 20, 'lengthB': 20, 'widthB': 19, 'heightB': 20}, {'lengthA': 190, 'widthA': 20, 'heightA': 200, 'lengthB': 200, 'widthB': 19, 'heightB': 200}, {'lengthA': 20, 'widthA': 20, 'heightA': 20, 'lengthB': 20, 'widthB': 20, 'heightB': 20}, {'lengthA': 2088888, 'widthA': 543987, 'heightA': 343765, 'lengthB': 765679, 'widthB': 5689589, 'heightB': 12358569}, {'lengthA': 136639, 'widthA': 546, 'heightA': 2357870987, 'lengthB': 1235654, 'widthB': 67989, 'heightB': 23345}]"
        },
        "outputs": [
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ],
        "meta": {
            "id": 9,
            "canonical_solution": "",
            "entry_point": "place_inside"
        }
    },
    "82": {
        "instruction": "Напишите программу по строке документации\n{function}",
        "inputs": {
            "function": "from typing import List\n\n\ndef peculiar_numbers(matrix: List[List[int]]) -> List[int]:\n    \"\"\"Красивым числом в матрице называется такое число, которое является строго наименьшим в своей строке и строго наибольшим в своем столбце. Выведите все уникальные красивые числа матрицы matrix в виде списка в порядке возрастания. Если таких чисел нет, выведите пустой список.\n    Примеры:\n       peculiar_numbers(matrix=[[4, 84, 8, 7, 91], [54, 65, 63, 24, 68], [77, 71, 78, 51, 67], [70, 87, 16, 20, 27], [95, 92, 98, 19, 48]]) == [51]\n       peculiar_numbers(matrix=[[33, 10, 32, 35, 75, 82], [52, 18, 29, 12, 48, 94], [75, 86, 32, 19, 84, 91], [41, 75, 85, 12, 7, 31], [25, 6, 11, 18, 14, 44], [44, 96, 97, 42, 91, 95]]) == [42]\n    \"\"\"",
            "tests": "[{'matrix': [[4, 84, 8, 7, 91], [54, 65, 63, 24, 68], [77, 71, 78, 51, 67], [70, 87, 16, 20, 27], [95, 92, 98, 19, 48]]}, {'matrix': [[33, 10, 32, 35, 75, 82], [52, 18, 29, 12, 48, 94], [75, 86, 32, 19, 84, 91], [41, 75, 85, 12, 7, 31], [25, 6, 11, 18, 14, 44], [44, 96, 97, 42, 91, 95]]}, {'matrix': [[40, 56, 90, 19, 87, 87], [79, 27, 59, 11, 40, 46], [28, 52, 6, 17, 68, 87], [90, 57, 78, 72, 69, 72], [98, 18, 24, 39, 89, 45], [59, 37, 98, 13, 1, 91]]}, {'matrix': [[35, 22, 1, 35, 37], [35, 3, 69, 38, 87], [71, 54, 98, 77, 66], [99, 20, 51, 82, 91], [36, 12, 54, 90, 9]]}, {'matrix': [[67, 97, 4, 24, 19], [68, 58, 90, 26, 65], [96, 30, 37, 26, 57], [21, 74, 23, 2, 76], [80, 79, 75, 18, 43]]}, {'matrix': [[69, 76, 48, 72, 29], [8, 35, 35, 45, 27], [90, 70, 85, 79, 60], [71, 13, 2, 40, 60], [94, 19, 11, 58, 3]]}, {'matrix': [[8, 27, 60, 53, 74], [15, 61, 48, 85, 24], [91, 66, 77, 86, 87], [12, 13, 46, 59, 9], [53, 56, 53, 61, 54]]}, {'matrix': [[78, 62, 88, 97, 63], [33, 5, 44, 53, 16], [64, 11, 59, 1, 69], [29, 43, 99, 46, 46], [82, 42, 5, 99, 93]]}, {'matrix': [[90, 69, 42, 81, 29, 68, 81], [37, 65, 45, 8, 6, 6, 20], [17, 48, 24, 63, 5, 1, 19], [33, 88, 26, 99, 20, 72, 14], [30, 25, 47, 88, 28, 31, 84], [5, 38, 91, 62, 19, 8, 13], [57, 49, 74, 87, 26, 66, 65]]}, {'matrix': [[16, 52, 64, 62, 99], [36, 40, 45, 26, 81], [87, 29, 90, 9, 62], [45, 8, 8, 69, 7], [76, 57, 64, 75, 60]]}]"
        },
        "outputs": [
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ],
        "meta": {
            "id": 82,
            "canonical_solution": "",
            "entry_point": "peculiar_numbers"
        }
    },
    "34": {
        "instruction": "Допишите код на языке Python в соответствии с условием, приведенным в описании\n{function}",
        "inputs": {
            "function": "def vendor_change(X: int, Y: int, Z: int, T: int) -> int:\n    \"\"\"Если товар стоит X рублей и Y копеек, а покупатель заплатил продавцу Z рублей и T копеек, то сколько копеек должна составить сдача? Гарантируется, что покупатель заплатил не более 100 рублей за товар. Выведите получившееся число.\n    Примеры:\n       vendor_change(X=3, Y=-3, Z=2, T=500) == 403\n       vendor_change(X=300, Y=0, Z=2000, T=5) == 170005\n    \"\"\"",
            "tests": "[{'X': 3, 'Y': -3, 'Z': 2, 'T': 500}, {'X': 300, 'Y': 0, 'Z': 2000, 'T': 5}, {'X': 30, 'Y': 60, 'Z': 199, 'T': 10}, {'X': 2, 'Y': 12, 'Z': 2, 'T': 12}, {'X': 200, 'Y': 55, 'Z': 300, 'T': 55}, {'X': 1000, 'Y': 99, 'Z': 1001, 'T': 98}, {'X': 1, 'Y': 98, 'Z': 2, 'T': 0}, {'X': 400, 'Y': 1, 'Z': 404, 'T': 66}, {'X': 15000, 'Y': 88, 'Z': 20000, 'T': 0}, {'X': 202000, 'Y': 33, 'Z': 202000, 'T': 44}]"
        },
        "outputs": [
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ],
        "meta": {
            "id": 34,
            "canonical_solution": "",
            "entry_point": "vendor_change"
        }
    },
    "85": {
        "instruction": "Дано описание функции, напиши программу на языке Python\n{function}",
        "inputs": {
            "function": "from typing import List\n\n\ndef merge_arrays(array1: List[int], array2: List[int]) -> List[int]:\n    \"\"\"Сформируйте список чисел так, чтобы в его начале шли все числа списка array1, которые также встречаются в списке array2 в порядке их вхождения в array2, а затем шли все остальные элементы array1 в порядке возрастания. Выведите полученный список.\n    Примеры:\n       merge_arrays(array1=[27, 30, 10, 11, 37, 38, 6, 9, 3, 33, 30, 13, 15], array2=[32, 15, 34, 37, 3, 38, 3]) == [15, 37, 3, 38, 6, 9, 10, 11, 13, 27, 30, 30, 33]\n       merge_arrays(array1=[39, 3, 17, 3, 36, 22, 8, 2, 21, 36, 33, 5, 28, 17], array2=[2, 20, 38, 4, 7, 8, 33, 3]) == [2, 8, 33, 3, 3, 5, 17, 17, 21, 22, 28, 36, 36, 39]\n    \"\"\"",
            "tests": "[{'array1': [27, 30, 10, 11, 37, 38, 6, 9, 3, 33, 30, 13, 15], 'array2': [32, 15, 34, 37, 3, 38, 3]}, {'array1': [39, 3, 17, 3, 36, 22, 8, 2, 21, 36, 33, 5, 28, 17], 'array2': [2, 20, 38, 4, 7, 8, 33, 3]}, {'array1': [4, 3, 23, 9, 18, 20, 32, 18, 34, 33, 4, 33, 23], 'array2': [16, 18, 12, 9, 12, 38, 21, 32]}, {'array1': [19, 30, 5, 12, 24, 24, 16, 12, 15, 16, 33, 31], 'array2': [1, 16, 14, 10, 7, 38, 10, 38, 6]}, {'array1': [15, 31, 1, 2, 8, 28, 9, 23, 14, 6, 12, 1, 7], 'array2': [18, 20, 36, 17, 25, 6, 9]}, {'array1': [21, 2, 21, 23, 12, 2, 36, 35, 23, 8, 7, 5, 10, 8], 'array2': [12, 27, 28, 13, 7, 32, 27]}, {'array1': [31, 26, 22, 1, 17, 11, 27, 9, 15, 31, 2, 39, 1, 20], 'array2': [21, 28, 39, 17, 30, 17, 2]}, {'array1': [17, 35, 17, 17, 33, 21, 12, 10, 3, 22, 14, 23], 'array2': [22, 9, 21, 38, 20, 3, 7, 1]}, {'array1': [30, 2, 1, 4, 18, 34, 17, 29, 7, 3, 31, 25], 'array2': [34, 33, 12, 17, 19, 28, 21, 38, 28]}, {'array1': [8, 22, 23, 31, 35, 34, 9, 15, 31, 20, 8, 27], 'array2': [6, 17, 35, 18, 20, 22, 13, 25]}]"
        },
        "outputs": [
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ],
        "meta": {
            "id": 85,
            "canonical_solution": "",
            "entry_point": "merge_arrays"
        }
    },
    "146": {
        "instruction": "На вход подается функция(ии) с описанием в виде строки docstring. В соответствии с описанием вам необходимо реализовать функцию(ии)\n{function}",
        "inputs": {
            "function": "from typing import List\n\n\ndef minimum_path(array: List[List[int]]) -> int:\n    \"\"\"Дан треугольный массив array. Выведите минимально возможную сумму элементов пути от начала array до конца. Из индекса K текущей строки можно переместиться только в индексы K и (K + 1) следующей строки. В треугольном массиве каждый следующий элемент имеет длину на единицу больше, чем предыдущий, начиная с 1. Для пустого array минимальный путь равен 0.\n    Примеры:\n       minimum_path(array=[[22], [13, 18], [1, 9, 10]]) == 22\n       minimum_path(array=[[22], [26, 20], [24, 31, 19], [14, 18, 17, 15], [8, 7, 14, 8, 8]]) == 22\n    \"\"\"",
            "tests": "[{'array': [[22], [13, 18], [1, 9, 10]]}, {'array': [[22], [26, 20], [24, 31, 19], [14, 18, 17, 15], [8, 7, 14, 8, 8]]}, {'array': [[26], [24, 27], [16, 28, 23], [13, 22, 21, 20], [8, 22, 21, 18, 19], [6, 9, 12, 7, 13, 7]]}, {'array': [[7], [6, 2], [14, 1, 10]]}, {'array': [[25], [15, 21], [15, 8, 17], [11, 11, 4, 5], [9, 10, 1, 11, 4]]}, {'array': [[27], [17, 20], [15, 18, 18], [11, 9, 4, 11], [14, 4, 2, 13, 1]]}, {'array': [[18], [9, 12], [9, 4, 14]]}, {'array': [[31], [35, 30], [36, 29, 24], [27, 23, 26, 22], [18, 17, 13, 23, 10], [8, 14, 8, 13, 11, 3]]}, {'array': [[41], [32, 40], [21, 29, 28], [17, 18, 20, 14], [23, 4, 9, 11, 16], [12, 13, 1, 5, 10, 10]]}, {'array': []}]"
        },
        "outputs": [
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ],
        "meta": {
            "id": 146,
            "canonical_solution": "",
            "entry_point": "minimum_path"
        }
    },
    "125": {
        "instruction": "Дано описание функции, напиши программу на языке Python\n{function}",
        "inputs": {
            "function": "from typing import List\n\n\ndef middle_index(array: List[int]) -> int:\n    \"\"\"Для целочисленного списка array найдите наименьший возможный такой индекс, что сумма всех элементов левее данного индекса равна сумме элементов списка правее данного индекса. Выведите полученный индекс или -1, если такого индекса не существует.\n    Примеры:\n       middle_index(array=[17, 12, 6, 5, 16, 8, 10, 9, 8, 5]) == 4\n       middle_index(array=[13, 12, 15, 0, 2, 11, 5, 16, 4, 7, 10]) == 5\n    \"\"\"",
            "tests": "[{'array': [17, 12, 6, 5, 16, 8, 10, 9, 8, 5]}, {'array': [13, 12, 15, 0, 2, 11, 5, 16, 4, 7, 10]}, {'array': [3, 2, 9, 3, 15, 4, 7, 1, 0, 15, 2, 7]}, {'array': [13, 5, 10, 13, 15, 12, 8, 18, 16, 11, 3]}, {'array': [17, 8, 3, 15, 1, 18, 2, 1, 7, 5, 9, 9, 11]}, {'array': [14, 9, 9, 7, 8, 11, 10, 1, 9, 1, 11, 7, 12, 17, 2, 9]}, {'array': [11, 19, 10, 5, 0, 9, 9, 17, 17, 17]}, {'array': [9, 2, 11, 2, 12, 14, 15, 9, 1, 5, 13, 0]}, {'array': [4, 12, 11, 18, 11, 7, 17, 6, 3, 19, 5, 12, 5, 16, 0]}, {'array': [0, 17, 17, 9, 11, 4, 11, 3, 8, 13, 15, 15, 19, 10]}]"
        },
        "outputs": [
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ],
        "meta": {
            "id": 125,
            "canonical_solution": "",
            "entry_point": "middle_index"
        }
    },
    "47": {
        "instruction": "По данному условию с фиксированной шапкой функции(ий) напиши программу\n{function}",
        "inputs": {
            "function": "from typing import List\n\n\ndef garmonic_mean(array: List[int]) -> float:\n    \"\"\"Дан массив из чисел array. Найдите среднее гармоническое данного массива. Среднее гармоническое массива равно частному размера массива и суммы чисел, которые равны обратным элементам массива (единица разделить на элемент массива). Гарантируется, что массив имеет хотя бы один элемент. Выведите получившееся число, округленное до 2 знаков после запятой.\n    Примеры:\n       garmonic_mean(array=[9, 1, 5, 9, 9, 9, 6, 5, 6]) == 4.13\n       garmonic_mean(array=[6, 7, 9, 1, 6]) == 3.15\n    \"\"\"",
            "tests": "[{'array': [9, 1, 5, 9, 9, 9, 6, 5, 6]}, {'array': [6, 7, 9, 1, 6]}, {'array': [8, 1, 8, 1, 2, 6, 4, 9, 2, 6, 4, 9]}, {'array': [9, 5, 4, 3, 7, 4, 8, 6, 4]}, {'array': [4, 5, 2, 7, 9, 6, 6, 9, 4, 2, 2, 1, 1]}, {'array': [8, 6, 1, 6, 4, 2, 5, 9, 8, 9, 5]}, {'array': [2, 9, 6, 5, 4, 4, 9, 5, 1, 4, 6, 2, 9]}, {'array': [2, 9, 9, 8, 9, 1, 3]}, {'array': [4, 3, 2, 8, 3, 1, 2, 4, 6, 4, 2]}, {'array': [9, 3, 6, 7, 3, 4, 4, 3]}]"
        },
        "outputs": [
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ],
        "meta": {
            "id": 47,
            "canonical_solution": "",
            "entry_point": "garmonic_mean"
        }
    },
    "20": {
        "instruction": "Реши задачу по программированию\n{function}",
        "inputs": {
            "function": "def second_index(string: str, symbol: str) -> int:\n    \"\"\"Выведите индекс второго вхождения символа symbol в строке string. Если второго вхождения нет, а также если строка string не содержит символ symbol, выведите число 0.\n    Примеры:\n       second_index(string=wxapqc, symbol=a) == 0\n       second_index(string=wetzjoqbzy, symbol=x) == 0\n    \"\"\"",
            "tests": "[{'string': 'wxapqc', 'symbol': 'a'}, {'string': 'wetzjoqbzy', 'symbol': 'x'}, {'string': 'ptejfoqxrgnhllyfblh', 'symbol': 'l'}, {'string': 'ayobteexn', 'symbol': 'e'}, {'string': 'swgbefreqscaiwtzxm', 'symbol': 'w'}, {'string': 'dfhto', 'symbol': 'n'}, {'string': 'wjf', 'symbol': 'w'}, {'string': 'wetzsmlnlsiaqzjoqbzy', 'symbol': 'l'}, {'string': 'slgyafufrlifznesy', 'symbol': 'f'}, {'string': 'ohnipkzzyaawkhln', 'symbol': 'z'}]"
        },
        "outputs": [
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ],
        "meta": {
            "id": 20,
            "canonical_solution": "",
            "entry_point": "second_index"
        }
    },
    "141": {
        "instruction": "Реализуй функцию(ии) на языке Python\n{function}",
        "inputs": {
            "function": "def divide_circle(number: int) -> int:\n    \"\"\"Определите, сколько необходимо сделать разрезов в окружности, чтобы получить number одинаковых частей. Разрезы можно делать либо по любому из диаметров окружности – прямая линия от одной точки окружности до другой, проходящая через центр окружности, либо по любому из ее радиусов – прямая от центра окружности до любой из точек на окружности. Выведите полученное число.\n    Примеры:\n       divide_circle(number=13) == 13\n       divide_circle(number=12) == 6\n    \"\"\"",
            "tests": "[{'number': 13}, {'number': 12}, {'number': 1}, {'number': 9}, {'number': 6}, {'number': 10}, {'number': 14}, {'number': 17}, {'number': 4}, {'number': 15}]"
        },
        "outputs": [
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ],
        "meta": {
            "id": 141,
            "canonical_solution": "",
            "entry_point": "divide_circle"
        }
    },
    "81": {
        "instruction": "Реализуй функцию(ии) на языке Python\n{function}",
        "inputs": {
            "function": "from typing import List\n\n\ndef shuffle_pairs(array: List[int]) -> List[int]:\n    \"\"\"В списке array длины 2 * N перегруппируйте элементы так, чтобы они шли парами в порядке array[i], array[N + i] для всех i от 0 до (N-1). Выведите полученный список. гарантируется, что N не больше 1000.\n    Примеры:\n       shuffle_pairs(array=[8, 6, 2, 9, 2, 1, 1, 7, 2, 7, 1, 1, 9, 7, 2, 8]) == [8, 2, 6, 7, 2, 1, 9, 1, 2, 9, 1, 7, 1, 2, 7, 8]\n       shuffle_pairs(array=[6, 5, 7, 6, 4, 1, 2, 5, 6, 4]) == [6, 1, 5, 2, 7, 5, 6, 6, 4, 4]\n    \"\"\"",
            "tests": "[{'array': [8, 6, 2, 9, 2, 1, 1, 7, 2, 7, 1, 1, 9, 7, 2, 8]}, {'array': [6, 5, 7, 6, 4, 1, 2, 5, 6, 4]}, {'array': [4, 9]}, {'array': [3, 2, 7, 8, 8, 2]}, {'array': [9, 3, 9, 5, 4, 3, 5, 5, 5, 7, 9, 9, 9, 9, 8, 1, 7, 8]}, {'array': [1, 5, 2, 6]}, {'array': [8, 8, 8, 8, 7, 1, 9, 9, 7, 3, 3, 4, 3, 8, 4, 3]}, {'array': [6, 3, 9, 4, 6, 7]}, {'array': [3, 7, 8, 6, 8, 5, 3, 5, 6, 6, 9, 1, 7, 3, 6, 8]}, {'array': [1, 4, 4, 9, 5, 5, 1, 6, 1, 7, 7, 9, 6, 8, 8, 8, 1, 1]}]"
        },
        "outputs": [
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ],
        "meta": {
            "id": 81,
            "canonical_solution": "",
            "entry_point": "shuffle_pairs"
        }
    },
    "117": {
        "instruction": "По данному условию с фиксированной шапкой функции(ий) напиши программу\n{function}",
        "inputs": {
            "function": "from typing import List\n\n\ndef identical_subarray(array: List[int], number: int) -> int:\n    \"\"\"Подпоследовательность списка array должна состоять только из одинаковых элементов, после удаления из списка array не более, чем number элементов. Определите длину наибольшей такой подпоследовательности целочисленного списка array. Выведите получившуюся длину.\n    Примеры:\n       identical_subarray(array=[6, 7, 7, 6, 5, 8, 2, 9, 9, 7, 8, 5, 6, 4, 7], number=9) == 3\n       identical_subarray(array=[4, 3, 1, 11, 7, 8, 9, 10, 4, 3], number=1) == 1\n    \"\"\"",
            "tests": "[{'array': [6, 7, 7, 6, 5, 8, 2, 9, 9, 7, 8, 5, 6, 4, 7], 'number': 9}, {'array': [4, 3, 1, 11, 7, 8, 9, 10, 4, 3], 'number': 1}, {'array': [2, 2, 10, 7, 5, 9, 6, 4, 4, 8, 4, 2, 2, 1, 2, 3, 1, 10, 1, 9, 7, 7], 'number': 8}, {'array': [11, 7, 9, 10, 10, 8, 4, 5, 5, 3, 8, 1, 9, 6, 9], 'number': 9}, {'array': [11, 5, 3, 2, 8, 5, 1, 8, 6, 11, 4, 4, 9, 1, 2, 3, 3, 7, 5, 7, 7, 10, 9], 'number': 2}, {'array': [5, 11, 4, 5, 4, 7, 7, 2, 10, 8, 11, 4, 6, 6, 6, 9, 3, 7, 5, 10, 8], 'number': 1}, {'array': [3, 3, 7, 5, 5, 5, 2, 2, 2, 11, 11, 2], 'number': 5}, {'array': [6, 8, 1, 5, 6, 5, 8, 5, 8, 2, 10, 5, 2, 11, 6, 4, 1, 4, 10, 10, 3, 9], 'number': 3}, {'array': [8, 5, 4, 2, 6, 4, 8, 10, 4, 2, 6, 11, 4, 7, 8, 1, 9, 6, 6, 8, 1], 'number': 9}, {'array': [6, 2, 1, 4, 6, 7, 8, 4, 10, 11, 10, 9, 10, 10, 5, 8, 2, 4, 6], 'number': 4}]"
        },
        "outputs": [
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ],
        "meta": {
            "id": 117,
            "canonical_solution": "",
            "entry_point": "identical_subarray"
        }
    },
    "157": {
        "instruction": "По данному условию с фиксированной шапкой функции(ий) напиши программу\n{function}",
        "inputs": {
            "function": "def words_only(string: str) -> str:\n    \"\"\"Дана строка string, которая состоит из алфавитных, цифровых и пунктуационных символов. Удалите из строки все неалфавитные символы, сохранив изначальный порядок остальных символов, и выведите получившуюся строку.\n    Примеры:\n       words_only(string=е2хм77м5) == 'ехмм'\n       words_only(string=яо8ота92и5) == 'яоотаи'\n    \"\"\"",
            "tests": "[{'string': 'е2хм77м5'}, {'string': 'яо8ота92и5'}, {'string': ''}, {'string': 'лу3ж050д5'}, {'string': 'ынт76ф40тщ2й'}, {'string': 'л37кцуа7цфсж0'}, {'string': '9рфъбт0афо7'}, {'string': 'лс6с2нна'}, {'string': '0зг96й992р'}, {'string': '123456789-='}]"
        },
        "outputs": [
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ],
        "meta": {
            "id": 157,
            "canonical_solution": "",
            "entry_point": "words_only"
        }
    },
    "142": {
        "instruction": "Напишите программу по строке документации\n{function}",
        "inputs": {
            "function": "def temperature_sum(number: float) -> float:\n    \"\"\"Переведите температуру number из градусов Цельсия (Celsius) в Кельвины (Kelvin) и в градусы Фаренгейта (Fahrenheit). Округлите каждое из полученных чисел до двух знаков после запятой и выведите сумму полученных чисел, также округленную до 2 знаков после запятой.\nКельвин = Цельсий + 273.15\nФаренгейт = Цельсий * 1.80 + 32.00\n    Примеры:\n       temperature_sum(number=-5.72) == 289.13\n       temperature_sum(number=0.85) == 307.53\n    \"\"\"",
            "tests": "[{'number': -5.72}, {'number': 0.85}, {'number': -3.73}, {'number': 7.65}, {'number': -6.17}, {'number': 11.42}, {'number': 6.61}, {'number': -7.84}, {'number': 11.82}, {'number': -9.67}]"
        },
        "outputs": [
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ],
        "meta": {
            "id": 142,
            "canonical_solution": "",
            "entry_point": "temperature_sum"
        }
    },
    "126": {
        "instruction": "На вход подается функция(ии) с описанием в виде строки docstring. В соответствии с описанием вам необходимо реализовать функцию(ии)\n{function}",
        "inputs": {
            "function": "from typing import List\n\n\ndef separate_words(array: List[str], symbol: str) -> List[str]:\n    \"\"\"Разделите все строки списка array по символу symbol и выведите полученный список разделенных строк в том же порядке, в котором они были в изначальном списке.\n    Примеры:\n       separate_words(array=['90в$ие5д86з34гзё1', 'ё$', '89з0$5б$е74', 'ёбб$0д', 'ги71$6$66гг', '51$'], symbol=$) == ['90в', 'ие5д86з34гзё1', 'ё', '89з0', '5б', 'е74', 'ёбб', '0д', 'ги71', '6', '66гг', '51']\n       separate_words(array=['94/1гбж1да43г9з', '2бе3аб/97гж0з89'], symbol=/) == ['94', '1гбж1да43г9з', '2бе3аб', '97гж0з89']\n    \"\"\"",
            "tests": "[{'array': ['90в$ие5д86з34гзё1', 'ё$', '89з0$5б$е74', 'ёбб$0д', 'ги71$6$66гг', '51$'], 'symbol': '$'}, {'array': ['94/1гбж1да43г9з', '2бе3аб/97гж0з89'], 'symbol': '/'}, {'array': ['14529~3014~ё', '0~69~з', '88~3и8в2557еи', '32~ёеёи', '14~бв~з'], 'symbol': '~'}, {'array': ['едвззгж/в0ед1', 'и/', '1и/з58ж930/бё2'], 'symbol': '/'}, {'array': ['з2ии709жж5+5ажзи5зз', '0+3жвдж', '31ж8ж597б7++7а9даг2аё', 'г610д318е+в27з'], 'symbol': '+'}, {'array': ['в?б?ё', '3д3дёе1е5а3?917дга0и', '0аагаи?га?34г', '68?6?90366з', 'в206адё280и??688649д6', 'ё?аж8'], 'symbol': '?'}, {'array': ['6*2аг5*б7аз666а', 'з*г6в7ёвбз0бж50вб', '0б5*06бв0*', '3ж7*в44еб88*0иа441ё0', 'е7*ёа'], 'symbol': '*'}, {'array': ['и6ж1е3жз8иб$71$0ёгзж', 'г2и8е$56вёед082$за23', '4бе2и478и$68а77$ё', '7$', '8$6зз8жб8б4аега25а$6'], 'symbol': '$'}, {'array': ['г3извиж§', 'вже2§45за3е§176в'], 'symbol': '§'}, {'array': ['9в@и82б1и3иг6в', '5г3дбд9@6аабвжа@гз', 'ё@ежб2531б4@дб', '6аё0ё82аизё6б3а3@бёв@', 'ба4бдиё89@ж99843а282', 'б9д624@ж3дж31в3'], 'symbol': '@'}]"
        },
        "outputs": [
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ],
        "meta": {
            "id": 126,
            "canonical_solution": "",
            "entry_point": "separate_words"
        }
    },
    "100": {
        "instruction": "Реши задачу по программированию\n{function}",
        "inputs": {
            "function": "def odd_substring(string: str) -> str:\n    \"\"\"Выберите из строки string, содержащей целое положительное число, подстроку так, чтобы она содержала наибольшее возможное нечетное число. Выведите полученную подстроку в виде строки. Если невозможно составить нечетное число, выведите пустую строку.\n    Примеры:\n       odd_substring(string=8016) == '801'\n       odd_substring(string=54468345) == '54468345'\n    \"\"\"",
            "tests": "[{'string': '8016'}, {'string': '54468345'}, {'string': '34452'}, {'string': '64830463'}, {'string': '621'}, {'string': '5824344'}, {'string': '244'}, {'string': '46717'}, {'string': '014499983'}, {'string': '31657'}]"
        },
        "outputs": [
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ],
        "meta": {
            "id": 100,
            "canonical_solution": "",
            "entry_point": "odd_substring"
        }
    },
    "113": {
        "instruction": "Необходимо реализовать логику на языке Python для следующей программы\n{function}",
        "inputs": {
            "function": "from typing import List\n\n\ndef equal_concatenations(array1: List[str], array2: List[str]) -> int:\n    \"\"\"Даны два непустых массива строк array1 и array2. Объедините все элементы в array1 в изначальном порядке в одну строку. Сделайте то же самое для array2. Определите, одинаковые ли строки получились. Если да, выведите 1, иначе выведите 0.\n    Примеры:\n       equal_concatenations(array1=['кяш', 'веэзю', 'им', 'дчжтущс', 'ъфла', 'ойбрц', 'хнып', 'ьг'], array2=['кяшвеэ', 'зюим', 'дчж', 'тущсъфл', 'аойбрцхн', 'ыпьг']) == 1\n       equal_concatenations(array1=['фгпнъдсяэытиьежйлоюамбквзцхущшрч'], array2=['фгпэытиьежйлоюамбквзцхущшрч']) == 0\n    \"\"\"",
            "tests": "[{'array1': ['кяш', 'веэзю', 'им', 'дчжтущс', 'ъфла', 'ойбрц', 'хнып', 'ьг'], 'array2': ['кяшвеэ', 'зюим', 'дчж', 'тущсъфл', 'аойбрцхн', 'ыпьг']}, {'array1': ['фгпнъдсяэытиьежйлоюамбквзцхущшрч'], 'array2': ['фгпэытиьежйлоюамбквзцхущшрч']}, {'array1': ['мъчу', 'зцквюх', 'еп', 'яьжсдлфрышщгон', 'абтийэ'], 'array2': ['мъ', 'чузц', 'квюхе', 'пяьжсдлфры', 'шщгонабтийэ']}, {'array1': ['кгъяй', 'юьесу', 'лриытзшдж', 'энопвщхмц', 'афбч'], 'array2': ['офйщякув', 'хетюч', 'ьцмсшыаэд', 'ъгнрлпзбжи']}, {'array1': ['смлыгр', 'хцпнвщдъош', 'еяьжфэйбюка', 'чзути'], 'array2': ['смлы', 'грхцп', 'нвщдъо', 'шеяь', 'жфэйб', 'юкачзути']}, {'array1': ['осх', 'шалзфюуй', 'ъбщгдкн', 'трпмьэжиыц', 'чвяе'], 'array2': ['осх', 'шалзфюуйъ', 'бщгдк', 'нпмьэжиы', 'цчвяе']}, {'array1': ['зшьр', 'ялуодбэвец', 'ъсжчмйапхгщтн', 'кфиюы'], 'array2': ['зшьрял', 'уодбэвец', 'ъсжчмйапхгщтн', 'кфиюы']}, {'array1': ['йшоеяры', 'ющгавнисцт', 'ъзфбжкдул', 'хпьчэм'], 'array2': ['ьгжхдтфо', 'эемюъ', 'ялкзсуыпи', 'ашвцщбйр', 'чн']}, {'array1': ['кшф', 'йцоду', 'тмьвю', 'яхечщ', 'рзлнсыиэбъ', 'гжпа'], 'array2': ['кшфй', 'цодут', 'мьвюяхеч', 'щрзлнсы', 'иэбъг', 'жпа']}, {'array1': ['чьщыб', 'сяэшмдйлз', 'хежпнък', 'юфтгцру', 'оива'], 'array2': ['щйядт', 'эарп', 'бнмежзъ', 'ксиыг', 'увшлюьц', 'чхфо']}]"
        },
        "outputs": [
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ],
        "meta": {
            "id": 113,
            "canonical_solution": "",
            "entry_point": "equal_concatenations"
        }
    },
    "111": {
        "instruction": "Реализуй функцию(ии) на языке Python\n{function}",
        "inputs": {
            "function": "def largest_box(start:int, end: int) -> int:\n    \"\"\"Мячи занумерованы числами от start до end включительно. Каждый мяч кладется в коробку, номер которой равен сумме цифр номера мяча. Выведите количество мячей в наиболее заполненной мячами коробке.\n    Примеры:\n       largest_box(start=542, end=600) == 6\n       largest_box(start=338, end=437) == 10\n    \"\"\"",
            "tests": "[{'start': 542, 'end': 600}, {'start': 338, 'end': 437}, {'start': 803, 'end': 824}, {'start': 620, 'end': 706}, {'start': 936, 'end': 1021}, {'start': 369, 'end': 416}, {'start': 708, 'end': 803}, {'start': 815, 'end': 880}, {'start': 645, 'end': 703}, {'start': 717, 'end': 790}]"
        },
        "outputs": [
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ],
        "meta": {
            "id": 111,
            "canonical_solution": "",
            "entry_point": "largest_box"
        }
    },
    "98": {
        "instruction": "Необходимо написать код по условию из строковой переменной документации, следующей после функции(ий)\n{function}",
        "inputs": {
            "function": "def pythagorean_triplets(number: int) -> int:\n    \"\"\"Дано целое положительное число number. Выведите количество троек целых чисел, каждое из которых больше или равно 1 и меньше или равно number, таких, что сумма квадратов первых двух чисел равна квадрату второго.\n    Примеры:\n       pythagorean_triplets(number=13) == 6\n       pythagorean_triplets(number=10) == 4\n    \"\"\"",
            "tests": "[{'number': 13}, {'number': 10}, {'number': 40}, {'number': 37}, {'number': 35}, {'number': 31}, {'number': 28}, {'number': 4}, {'number': 12}, {'number': 14}]"
        },
        "outputs": [
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ],
        "meta": {
            "id": 98,
            "canonical_solution": "",
            "entry_point": "pythagorean_triplets"
        }
    },
    "29": {
        "instruction": "Дан шаблон функции(ий) с описанием работы этой функции в качестве условия задачи. Допишите программу\n{function}",
        "inputs": {
            "function": "from typing import List\n\n\ndef squeeze_array(array: List[int]) -> List[int]:\n    \"\"\"Переместите все элементы массива array со значением 0 в конец списка, сохранив порядок всех остальных элементов. Выведите полученный список.\n    Примеры:\n       squeeze_array(array=[]) == []\n       squeeze_array(array=[3, 2, 3, 2, 3, 1]) == [3, 2, 3, 2, 3, 1]\n    \"\"\"",
            "tests": "[{'array': []}, {'array': [3, 2, 3, 2, 3, 1]}, {'array': [1, 1, 4, 2, 4]}, {'array': [2, 0, 3, 3, 1, 0, 4, 2, 0]}, {'array': [3, 2, 4, 0, 3, 0, 1, 3, 2, 1, 4, 1, 4]}, {'array': [3, 2, 3, 4, 0, 0, 1, 3, 2]}, {'array': [3, 1, 1, 1, 3]}, {'array': [0, 1, 1, 0, 0, 0, 4, 4]}, {'array': [2, 0, 0, 2, 3, 1, 2, 0, 1]}, {'array': [1, 0, 4, 2, 4, 1, 3, 3, 2, 0]}]"
        },
        "outputs": [
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ],
        "meta": {
            "id": 29,
            "canonical_solution": "",
            "entry_point": "squeeze_array"
        }
    },
    "84": {
        "instruction": "Допишите код на языке Python в соответствии с условием, приведенным в описании\n{function}",
        "inputs": {
            "function": "def digits_difference(number: int) -> int:\n    \"\"\"Выведите разность между произведением цифр числа number и суммой его цифр.\n    Примеры:\n       digits_difference(number=2) == 0\n       digits_difference(number=28) == 6\n    \"\"\"",
            "tests": "[{'number': 2}, {'number': 28}, {'number': 387}, {'number': 1234}, {'number': 3568}, {'number': 876543}, {'number': 6}, {'number': 496}, {'number': 8128}, {'number': 98376}]"
        },
        "outputs": [
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ],
        "meta": {
            "id": 84,
            "canonical_solution": "",
            "entry_point": "digits_difference"
        }
    },
    "119": {
        "instruction": "Дан шаблон функции(ий) с описанием работы этой функции в качестве условия задачи. Допишите программу\n{function}",
        "inputs": {
            "function": "def percentage_frequency(string: str, symbol: str) -> int:\n    \"\"\"Каков процент количества появлений символа symbol от всех символов строки string? Выведите процент, округленный вниз до ближайшего целого числа.\n    Примеры:\n       percentage_frequency(string=флюгегехаймен, symbol=й) == 7\n       percentage_frequency(string=метафора, symbol=а) == 25\n    \"\"\"",
            "tests": "[{'string': 'флюгегехаймен', 'symbol': 'й'}, {'string': 'метафора', 'symbol': 'а'}, {'string': 'ааааааааааааааааааааааааа', 'symbol': 'з'}, {'string': 'бйпдщвэсчьомхипцйтпчхфьтйкзцйгэбфцццкфг', 'symbol': 'ф'}, {'string': 'йишууфмпнхгэзвбфхагыхужос', 'symbol': 'э'}, {'string': 'яакйыщщрьялллкбфпжебтчгбялсымкуэффнд', 'symbol': 'к'}, {'string': 'этявопсппяссгфяжкпнчьязэтдрц', 'symbol': 'п'}, {'string': '', 'symbol': 'а'}, {'string': 'зччффгучвц', 'symbol': 'г'}, {'string': 'айцшчувжяюнлэрцэсчвъютшчкрьлтзязйидоеса', 'symbol': 'э'}]"
        },
        "outputs": [
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ],
        "meta": {
            "id": 119,
            "canonical_solution": "",
            "entry_point": "percentage_frequency"
        }
    },
    "153": {
        "instruction": "Необходимо реализовать логику на языке Python для следующей программы\n{function}",
        "inputs": {
            "function": "def number_palindromes(string: str) -> int:\n    \"\"\"Выведите количество подстрок в строке string, которые являются палиндромами. Палиндромом является строка, которая одинаково выглядит при чтении слева-направо и справа-налево. Подстрока из 1 символа всегда является палиндромом.\n    Примеры:\n       number_palindromes(string=метафора) == 8\n       number_palindromes(string=флюгегехаймен) == 15\n    \"\"\"",
            "tests": "[{'string': 'метафора'}, {'string': 'флюгегехаймен'}, {'string': 'без труда не выловишь и рыбку из пруда'}, {'string': 'бесплатный сыр, бывает- только в мышеловке'}, {'string': 'бог шельму= метит'}, {'string': 'в здоровом теле – здоровый дух'}, {'string': 'волков бояться – в лес не ходить'}, {'string': 'глаза боятся, а руки делают'}, {'string': 'готовь сани летом, а телегу зимой'}, {'string': 'дарёному коню в зубы не смотрят'}]"
        },
        "outputs": [
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ],
        "meta": {
            "id": 153,
            "canonical_solution": "",
            "entry_point": "number_palindromes"
        }
    },
    "90": {
        "instruction": "Реши задачу по программированию\n{function}",
        "inputs": {
            "function": "def beautiful_number(number: int) -> str:\n    \"\"\"Число называется красивым, если путем конечного числа разрешенных операций оно превращается в 1. Разрешенным действием для числа является его замена на сумму квадратов его цифр. Определите, является ли число number красивым. Если да, то выведите \"Да\", иначе выведите \"Нет\". Если разрешенные операции приводят к бесконечному циклу повторяющихся результатов, то такое число не является красивым.\n    Примеры:\n       beautiful_number(number=2) == 'Нет'\n       beautiful_number(number=28) == 'Да'\n    \"\"\"",
            "tests": "[{'number': 2}, {'number': 28}, {'number': 387}, {'number': 1234}, {'number': 3568}, {'number': 876543}, {'number': 6}, {'number': 496}, {'number': 8128}, {'number': 98376}]"
        },
        "outputs": [
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ],
        "meta": {
            "id": 90,
            "canonical_solution": "",
            "entry_point": "beautiful_number"
        }
    },
    "24": {
        "instruction": "Допишите код на языке Python в соответствии с условием, приведенным в описании\n{function}",
        "inputs": {
            "function": "from typing import List\n\n\ndef select_squares(array: List[int]) -> List[int]:\n    \"\"\"Выберите из массива array все квадраты целых чисел и выведите их в том порядке, в котором они указаны в массиве. Гарантируется, что array не пуст. Если в array нет ни одного подходящего под условие числа, выведите пустой список.\n    Примеры:\n       select_squares(array=[10, 36, 21, 80, 93, 4]) == [36, 4]\n       select_squares(array=[35, 18, 4, 15, 62, 72]) == [4]\n    \"\"\"",
            "tests": "[{'array': [10, 36, 21, 80, 93, 4]}, {'array': [35, 18, 4, 15, 62, 72]}, {'array': [37, 43, 32, 84, 38, 38, 67, 28, 50, 25]}, {'array': [23, 49, 42, 92, 38, 4, 34, 97, 71, 10, 63, 19, 63]}, {'array': [53, 39, 16, 98, 13, 7, 64, 88, 96, 73, 29, 81]}, {'array': [85, 78, 42, 38, 42, 40, 85, 51, 13, 92]}, {'array': [38, 45, 66, 10, 80, 52, 70, 93, 12, 52]}, {'array': [72, 12, 59, 31, 84, 38, 20, 97, 23, 46, 3, 32, 85, 99]}, {'array': [24, 55, 87, 47, 43, 55, 20, 31]}, {'array': [73, 78, 35, 23, 8, 89, 94, 22]}]"
        },
        "outputs": [
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ],
        "meta": {
            "id": 24,
            "canonical_solution": "",
            "entry_point": "select_squares"
        }
    },
    "73": {
        "instruction": "Необходимо реализовать логику на языке Python для следующей программы\n{function}",
        "inputs": {
            "function": "from typing import List\n\n\ndef largest_triangle(array: List[List[int]]) -> float:\n    \"\"\"На вход дан список array из пар координат точек в декартовой системе координат. Найдите три точки, которые формируют наибольший по площади треугольник и выведите его площадь. Считайте, в массиве есть как минимум одна тройка точек, которые формируют треугольник. Точки всегда лежат в первой четверти системы координат. Округлите ответ до 2 знаков после запятой.\n    Примеры:\n       largest_triangle(array=[[5, 3], [5, 1], [4, 7], [6, 4], [5, 6], [2, 1]]) == 9.0\n       largest_triangle(array=[[4, 8], [4, 6], [3, 1], [9, 2], [4, 9], [7, 2], [7, 7], [7, 9], [1, 1]]) == 30.5\n    \"\"\"",
            "tests": "[{'array': [[5, 3], [5, 1], [4, 7], [6, 4], [5, 6], [2, 1]]}, {'array': [[4, 8], [4, 6], [3, 1], [9, 2], [4, 9], [7, 2], [7, 7], [7, 9], [1, 1]]}, {'array': [[4, 7], [5, 1], [7, 8], [5, 8], [4, 8], [5, 4]]}, {'array': [[3, 8], [8, 4], [8, 2], [3, 8], [2, 8], [7, 6], [4, 3], [2, 4], [7, 9]]}, {'array': [[3, 1], [8, 8], [6, 4], [7, 9], [8, 2], [6, 7], [5, 6], [1, 6]]}, {'array': [[6, 9], [8, 1], [3, 4], [3, 4], [5, 5], [8, 2]]}, {'array': [[2, 4], [3, 8], [9, 2], [1, 8], [4, 6], [8, 5], [5, 8], [4, 7]]}, {'array': [[5, 2], [9, 4], [4, 9], [8, 5], [3, 2], [1, 5], [7, 3], [8, 9]]}, {'array': [[3, 1], [2, 2], [7, 6], [8, 2], [2, 6], [1, 5]]}, {'array': [[8, 5], [5, 8], [6, 3], [5, 9], [1, 7], [9, 1], [9, 4], [7, 7]]}]"
        },
        "outputs": [
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ],
        "meta": {
            "id": 73,
            "canonical_solution": "",
            "entry_point": "largest_triangle"
        }
    },
    "46": {
        "instruction": "На вход подается функция(ии) с описанием в виде строки docstring. В соответствии с описанием вам необходимо реализовать функцию(ии)\n{function}",
        "inputs": {
            "function": "from typing import List\n\n\ndef geometric_mean(array: List[int]) -> float:\n    \"\"\"Дан массив из чисел array. Найдите среднее геометрическое данного массива. Среднее геометрическое массива равно произведению всех чисел массива, из которого взят арифметический корень степени равной количеству элементов в массиве. Гарантируется, что массив имеет хотя бы один элемент. Выведите получившееся число, округленное до 2 знаков после запятой.\n    Примеры:\n       geometric_mean(array=[8, 6, 5, 4, 9, 3]) == 5.44\n       geometric_mean(array=[8, 4, 8, 9, 1, 5, 7, 8, 6, 1, 7, 1, 2, 1]) == 3.57\n    \"\"\"",
            "tests": "[{'array': [8, 6, 5, 4, 9, 3]}, {'array': [8, 4, 8, 9, 1, 5, 7, 8, 6, 1, 7, 1, 2, 1]}, {'array': [9, 9, 6, 2, 4, 1, 4, 3, 9, 3]}, {'array': [2, 9, 3, 8, 1, 1, 6]}, {'array': [9, 6, 5, 1, 7, 8, 3]}, {'array': [8, 7, 9, 9, 7, 9, 2, 6, 2, 8]}, {'array': [1, 8, 7, 9, 9]}, {'array': [2, 4, 4, 5, 3, 7, 8, 6]}, {'array': [5, 6, 3, 5, 9, 3, 1, 3, 6, 8, 4, 1, 9]}, {'array': [9, 9, 3, 3, 5, 3, 9, 5, 1, 1, 4, 3, 3]}]"
        },
        "outputs": [
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ],
        "meta": {
            "id": 46,
            "canonical_solution": "",
            "entry_point": "geometric_mean"
        }
    },
    "79": {
        "instruction": "Дан шаблон функции(ий) с описанием работы этой функции в качестве условия задачи. Допишите программу\n{function}",
        "inputs": {
            "function": "from typing import List\n\n\ndef string_shuffle(string: str, array: List[int]) -> str:\n    \"\"\"Перемешайте символы строки string так, чтобы символ с индексом i стал символом с индексом array[i], где array – список целых чисел от 0 до длины string минус 1. Выведите полученную строку.\n    Примеры:\n       string_shuffle(string=лташбпркцк, array=[7, 2, 3, 5, 8, 0, 9, 4, 1, 6]) == 'пцтакшклбр'\n       string_shuffle(string=юязшьщзсрхнае, array=[10, 6, 9, 2, 7, 5, 12, 0, 1, 11, 3, 8, 4]) == 'сршнещяьазюхз'\n    \"\"\"",
            "tests": "[{'string': 'лташбпркцк', 'array': [7, 2, 3, 5, 8, 0, 9, 4, 1, 6]}, {'string': 'юязшьщзсрхнае', 'array': [10, 6, 9, 2, 7, 5, 12, 0, 1, 11, 3, 8, 4]}, {'string': 'цзлусьъкхп', 'array': [3, 1, 4, 5, 8, 0, 7, 9, 6, 2]}, {'string': 'еябцтнибэлшолцчклййфвьрюеошъоь', 'array': [5, 3, 16, 6, 22, 18, 27, 26, 23, 14, 4, 25, 24, 19, 13, 11, 21, 9, 15, 20, 8, 0, 2, 10, 12, 29, 1, 7, 17, 28]}, {'string': 'йзхедщьчуъкхпгоощьэнлшгон', 'array': [9, 14, 17, 7, 3, 1, 18, 22, 20, 4, 6, 10, 24, 0, 13, 23, 8, 19, 15, 5, 16, 2, 12, 11, 21]}, {'string': 'внлкшзггнзрдблуоущбжпеочсбтш', 'array': [13, 14, 23, 10, 8, 1, 3, 5, 26, 12, 19, 16, 20, 9, 7, 15, 27, 4, 17, 18, 11, 6, 25, 0, 22, 21, 24, 2]}, {'string': 'рреопищьхштьмгызямйпег', 'array': [7, 17, 6, 0, 12, 21, 11, 19, 9, 18, 13, 4, 10, 3, 20, 15, 16, 14, 2, 1, 8, 5]}, {'string': 'ядмтщпымкмгрмэвътмндйэт', 'array': [11, 0, 6, 9, 17, 4, 1, 14, 2, 18, 13, 5, 16, 7, 10, 8, 19, 20, 21, 15, 22, 3, 12]}, {'string': 'яугоюфагымк', 'array': [8, 9, 10, 1, 6, 5, 7, 2, 4, 0, 3]}, {'string': 'чьэтпхшхщяскдеьжвццйкфх', 'array': [8, 21, 17, 18, 13, 2, 15, 10, 11, 7, 20, 9, 3, 16, 22, 4, 0, 6, 12, 5, 1, 19, 14]}]"
        },
        "outputs": [
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ],
        "meta": {
            "id": 79,
            "canonical_solution": "",
            "entry_point": "string_shuffle"
        }
    },
    "80": {
        "instruction": "Реши задачу по программированию\n{function}",
        "inputs": {
            "function": "from typing import List\n\n\ndef unequal_pairs(array: List[int]) -> int:\n    \"\"\"Выведите количество таких пар чисел в списке array, в которых первое число равно второму, но индекс первого числа строго меньше индекса второго числа в array.\n    Примеры:\n       unequal_pairs(array=[9, 7, 3, 3, 5, 2, 3, 4, 9, 4]) == 5\n       unequal_pairs(array=[5, 6, 8, 4, 3]) == 0\n    \"\"\"",
            "tests": "[{'array': [9, 7, 3, 3, 5, 2, 3, 4, 9, 4]}, {'array': [5, 6, 8, 4, 3]}, {'array': [3, 3, 2, 9, 7, 6, 4, 2, 3, 9, 4, 2, 6, 5]}, {'array': []}, {'array': [2, 7, 4, 9, 5, 9, 1, 1, 4, 9, 4]}, {'array': [3, 5, 4, 4, 2, 2, 9]}, {'array': [1, 6, 9, 2, 3, 6, 3]}, {'array': [2, 5, 9, 3, 1]}, {'array': [2, 8, 9, 1, 6, 6, 7, 3, 2, 7, 7]}, {'array': [9, 1, 3, 6, 5, 7]}]"
        },
        "outputs": [
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ],
        "meta": {
            "id": 80,
            "canonical_solution": "",
            "entry_point": "unequal_pairs"
        }
    },
    "106": {
        "instruction": "На вход подается функция(ии) с описанием в виде строки docstring. В соответствии с описанием вам необходимо реализовать функцию(ии)\n{function}",
        "inputs": {
            "function": "def equal_swap(string: str, target: str) -> str:\n    \"\"\"Если строку string можно сделать равной строке target путем перестановки местами ровно двух символов в string, то выведите \"Да\". Иначе, выведите \"Нет\".\n    Примеры:\n       equal_swap(string1=ащщснишплсдк, string2=ую) == 'Нет'\n       equal_swap(string1=ес, string2=се) == 'Да'\n    \"\"\"",
            "tests": "[{'string1': 'ащщснишплсдк', 'string2': 'ую'}, {'string1': 'ес', 'string2': 'се'}, {'string1': 'ефдкпхтаь', 'string2': 'ааеюх'}, {'string1': 'ъж', 'string2': 'бтфьэмрл'}, {'string1': 'учднжбнхькгегл', 'string2': 'пйпфлфёиаа'}, {'string1': 'ияыэ', 'string2': 'хфолецах'}, {'string1': 'ёмбжгъцаекл', 'string2': 'ёцбжгъмаекл'}, {'string1': 'пспыожъи', 'string2': 'мжфюэмъьйуьях'}, {'string1': 'ыовухутцибуми', 'string2': 'цгё'}, {'string1': 'сцярьыйжшрцтэю', 'string2': 'сцяюьыйжшрцтэр'}]"
        },
        "outputs": [
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ],
        "meta": {
            "id": 106,
            "canonical_solution": "",
            "entry_point": "equal_swap"
        }
    },
    "37": {
        "instruction": "По данному условию с фиксированной шапкой функции(ий) напиши программу\n{function}",
        "inputs": {
            "function": "def triangle_perimeter(A: int, B: int, C: int, D: int, E: int, F: int) -> float:\n    \"\"\"Вам даны координаты трех вершин треугольника в декартовой системе координат: первая вершина (A, B), вторая вершина (C, D), третья вершина (E, F). Вычислите и выведите периметр данного треугольника. Периметр треугольника равен сумме длин его сторон. Считайте, что три вершины всегда образуют треугольник. Округлите ответ до 2 знаков после запятой.\n    Примеры:\n       triangle_perimeter(A=3, B=-3, C=0, D=0, E=0, F=2000) == 4007.24\n       triangle_perimeter(A=0, B=-1, C=3, D=2, E=12, F=2) == 25.61\n    \"\"\"",
            "tests": "[{'A': 3, 'B': -3, 'C': 0, 'D': 0, 'E': 0, 'F': 2000}, {'A': 0, 'B': -1, 'C': 3, 'D': 2, 'E': 12, 'F': 2}, {'A': 1, 'B': 20, 'C': 20, 'D': 400, 'E': 1, 'F': 404}, {'A': -33, 'B': 66, 'C': 222, 'D': 1000, 'E': 99, 'F': 1001}, {'A': 0, 'B': 0, 'C': 3, 'D': 15000, 'E': 88, 'F': 20000}, {'A': 2, 'B': 3, 'C': 5, 'D': 1, 'E': 98, 'F': 2}, {'A': -3, 'B': -3, 'C': 1, 'D': 200, 'E': 55, 'F': 300}, {'A': 3, 'B': 5, 'C': 7, 'D': 1000, 'E': 99, 'F': 1001}, {'A': 0, 'B': 0, 'C': 0, 'D': 0, 'E': 0, 'F': 0}, {'A': -3003, 'B': 505, 'C': 222, 'D': 30, 'E': 60, 'F': 199}]"
        },
        "outputs": [
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ],
        "meta": {
            "id": 37,
            "canonical_solution": "",
            "entry_point": "triangle_perimeter"
        }
    },
    "160": {
        "instruction": "Реши задачу по программированию\n{function}",
        "inputs": {
            "function": "from typing import List\n\n\ndef missing_binary(array: List[str]) -> str:\n    \"\"\"Дан массив строк array, состоящий из двоичных чисел одинаковой длины. Определите двоичное число такой же длины, как числа в array, которого не хватает и выведите его в формате строки. Гарантируется, что ответ уникален.\n    Примеры:\n       missing_binary(array=['1']) == '0'\n       missing_binary(array=['00', '10', '11']) == '01'\n    \"\"\"",
            "tests": "[{'array': ['1']}, {'array': ['00', '10', '11']}, {'array': ['000', '001', '010', '011', '101', '110', '111']}, {'array': ['0000', '0001', '0010', '0011', '0100', '0101', '0110', '0111', '1000', '1001', '1010', '1011', '1101', '1110', '1111']}, {'array': ['00000', '00001', '00010', '00011', '00100', '00110', '00111', '01000', '01001', '01010', '01011', '01100', '01101', '01110', '01111', '10000', '10001', '10010', '10011', '10100', '10101', '10110', '10111', '11000', '11001', '11010', '11011', '11100', '11101', '11110', '11111']}, {'array': ['000000', '000001', '000010', '000011', '000100', '000101', '000110', '000111', '001000', '001001', '001010', '001011', '001100', '001101', '001110', '001111', '010000', '010001', '010010', '010011', '010100', '010101', '010110', '010111', '011000', '011001', '011010', '011011', '011100', '011101', '011110', '011111', '100000', '100001', '100010', '100011', '100100', '100101', '100110', '100111', '101000', '101001', '101010', '101011', '101100', '101101', '101110', '101111', '110000', '110001', '110010', '110011', '110100', '110101', '110110', '110111', '111000', '111001', '111010', '111011', '111100', '111101', '111111']}, {'array': ['0000000', '0000001', '0000010', '0000011', '0000100', '0000101', '0000110', '0000111', '0001000', '0001001', '0001010', '0001011', '0001100', '0001101', '0001110', '0001111', '0010000', '0010001', '0010010', '0010011', '0010100', '0010101', '0010110', '0010111', '0011000', '0011001', '0011010', '0011011', '0011100', '0011101', '0011110', '0011111', '0100000', '0100001', '0100010', '0100011', '0100100', '0100101', '0100110', '0100111', '0101000', '0101001', '0101010', '0101011', '0101100', '0101101', '0101110', '0101111', '0110000', '0110001', '0110010', '0110011', '0110100', '0110101', '0110110', '0110111', '0111000', '0111001', '0111010', '0111011', '0111100', '0111101', '0111110', '0111111', '1000000', '1000001', '1000010', '1000011', '1000100', '1000101', '1000110', '1000111', '1001000', '1001001', '1001010', '1001011', '1001101', '1001110', '1001111', '1010000', '1010001', '1010010', '1010011', '1010100', '1010101', '1010110', '1010111', '1011000', '1011001', '1011010', '1011011', '1011100', '1011101', '1011110', '1011111', '1100000', '1100001', '1100010', '1100011', '1100100', '1100101', '1100110', '1100111', '1101000', '1101001', '1101010', '1101011', '1101100', '1101101', '1101110', '1101111', '1110000', '1110001', '1110010', '1110011', '1110100', '1110101', '1110110', '1110111', '1111000', '1111001', '1111010', '1111011', '1111100', '1111101', '1111110', '1111111']}]"
        },
        "outputs": [
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ],
        "meta": {
            "id": 160,
            "canonical_solution": "",
            "entry_point": "missing_binary"
        }
    },
    "10": {
        "instruction": "Реши задачу по программированию\n{function}",
        "inputs": {
            "function": "def factorization(number: int) -> str:\n    \"\"\"Вам дано число number. Определите, можно ли его представить, как сумму некоторого количества троек и пятерок. Если можно, выведите \"Да\", иначе – \"Нет\".\n    Примеры:\n       factorization(number=1) == 'Нет'\n       factorization(number=3) == 'Да'\n    \"\"\"",
            "tests": "[{'number': 1}, {'number': 3}, {'number': 4}, {'number': 7}, {'number': 2}, {'number': 10}, {'number': 88}, {'number': 927}, {'number': 1453}, {'number': 9837246}]"
        },
        "outputs": [
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ],
        "meta": {
            "id": 10,
            "canonical_solution": "",
            "entry_point": "factorization"
        }
    },
    "48": {
        "instruction": "Необходимо написать код по условию из строковой переменной документации, следующей после функции(ий)\n{function}",
        "inputs": {
            "function": "from typing import List\n\n\ndef array_mode(array: List[int]) -> int:\n    \"\"\"Дан массив из чисел array. Найдите моду данного массива. Модой массива чисел является число, которое встречается в данном массиве чаще всего. Если таких значений больше, чем одно, то выведите наименьшее из них. Если в массиве нет ни одной моды, выведите минимальный элемент массива. Гарантируется, что массив не пуст.\n    Примеры:\n       array_mode(array=[4, 2, 7, 9, 1, 5, 6, 9, 6, 6, 7, 1, 6, 6]) == 6\n       array_mode(array=[6, 9, 7, 7, 4]) == 7\n    \"\"\"",
            "tests": "[{'array': [4, 2, 7, 9, 1, 5, 6, 9, 6, 6, 7, 1, 6, 6]}, {'array': [6, 9, 7, 7, 4]}, {'array': [3, 3, 5, 6, 5, 9, 4, 7]}, {'array': [6, 3, 2, 3, 7, 3, 8]}, {'array': [8, 2, 2, 2, 4, 6, 8, 9, 4, 9, 6, 2, 8]}, {'array': [1, 1, 6, 2, 5, 7, 8]}, {'array': [5, 6, 1, 2, 4, 9, 4, 4, 6, 6, 1, 8, 5, 5]}, {'array': [6, 5, 3, 5, 7, 7, 2, 6, 6, 8, 7, 8]}, {'array': [8, 2, 6, 3, 7]}, {'array': [5, 4, 3, 5, 8, 5]}]"
        },
        "outputs": [
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ],
        "meta": {
            "id": 48,
            "canonical_solution": "",
            "entry_point": "array_mode"
        }
    },
    "15": {
        "instruction": "Дано описание функции, напиши программу на языке Python\n{function}",
        "inputs": {
            "function": "from typing import List\n\n\ndef second_maximum(array: List[int]) -> int:\n    \"\"\"Выведите значение второго по величине максимума в списке array. Гарантируется, что array содержит не менее двух элементов.\n    Примеры:\n       second_maximum(array=[-96, -97, -27, -30, 93]) == -27\n       second_maximum(array=[-77, 67, 19, -71, 93, -50, -100, -77, 3, 51]) == 67\n    \"\"\"",
            "tests": "[{'array': [-96, -97, -27, -30, 93]}, {'array': [-77, 67, 19, -71, 93, -50, -100, -77, 3, 51]}, {'array': [29, -78, 73, -25, -18, -15, -4, 71, -48, 89, 95]}, {'array': [-40, 46, -55, -98, 81, 92, 44, 16, 30]}, {'array': [78, 45, -49, -84, 46, -28, 76, -98, -14, 44, 83, 57, 39]}, {'array': [18, 90, -37, 28, 20, -17, -96, 83, -47, 22]}, {'array': [59, -22, -78, 32, 33, 94, -70, -50]}, {'array': [-32, -11, 5, 23, 61, 55, -5, -60, -29]}, {'array': [30, 87, -32, 53, -29, -70, -38, -46, -98, -39]}, {'array': [6, -75, 66, -52, -77, 5, 93, -39, -3, 74]}]"
        },
        "outputs": [
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ],
        "meta": {
            "id": 15,
            "canonical_solution": "",
            "entry_point": "second_maximum"
        }
    },
    "68": {
        "instruction": "Необходимо написать код по условию из строковой переменной документации, следующей после функции(ий)\n{function}",
        "inputs": {
            "function": "def perfect_number(number: int) -> str:\n    \"\"\"Определите, является ли число number красивым. Красивое число – это такое число, которое равно сумме своих натуральных делителей (не включая само число number). Выведите \"Да\", если является. Иначе, выведите \"Нет\".\n    Примеры:\n       perfect_number(number=2) == 'Нет'\n       perfect_number(number=28) == 'Да'\n    \"\"\"",
            "tests": "[{'number': 2}, {'number': 28}, {'number': 387}, {'number': 1234}, {'number': 3568}, {'number': 876543}, {'number': 6}, {'number': 0}, {'number': 8128}, {'number': 98376}]"
        },
        "outputs": [
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ],
        "meta": {
            "id": 68,
            "canonical_solution": "",
            "entry_point": "perfect_number"
        }
    },
    "58": {
        "instruction": "Необходимо написать код по условию из строковой переменной документации, следующей после функции(ий)\n{function}",
        "inputs": {
            "function": "def inverse_vowels(string: str) -> str:\n    \"\"\"Измените строку string так, чтобы все гласные буквы в ней шли в обратном порядке относительно изначального порядка. Выведите получившуюся строку. Гласными являются буквы: а, о, и, у, е, ю, я, э, ы. Данные буквы могут встречаться в любом регистре.\n    Примеры:\n       inverse_vowels(string=Флюгегехаймен) == 'Флегагехеймюн'\n       inverse_vowels(string=метафора-анаформа) == 'матофара-анофарме'\n    \"\"\"",
            "tests": "[{'string': 'Флюгегехаймен'}, {'string': 'метафора-анаформа'}, {'string': 'фвьъыткиеплщклчкдтрпбррлкъъчюрямйьзх'}, {'string': 'тцнсщячбеоагясшжацбспарлшыуыцясьойтэшшытяю'}, {'string': 'ммйывуяяиттхфбнкгшьктачдучичц'}, {'string': 'ищснечицсвпбчвыэпииртикиоьбофътнднвтхиождйзв'}, {'string': 'иглюбгбшблиикаавмувпйфебр'}, {'string': 'выитшшчвяьучхпныюцфагжъошпфчттьрв'}, {'string': 'ялышшбтъцшщсрхтхюьебгвшвфмцгтюшж'}, {'string': 'эхнзыидаэзьцюцмзщгпэйтбфгфнал'}]"
        },
        "outputs": [
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ],
        "meta": {
            "id": 58,
            "canonical_solution": "",
            "entry_point": "inverse_vowels"
        }
    },
    "93": {
        "instruction": "Необходимо реализовать логику на языке Python для следующей программы\n{function}",
        "inputs": {
            "function": "from typing import List\n\n\ndef words_dictionary(array: List[str]) -> dict:\n    \"\"\"Дан список слов array. Создайте словарь, где ключами будут слова из списка, а значениями – порядковые номера данных слов в списке. Выведите получившийся словарь. Гарантируется, что слова в списке уникальные.\n    Примеры:\n       words_dictionary(array=['зэшхкхэр', 'ъщнкшбжм', 'агшф', 'птчую', 'лбфигхъймщв', 'ющкйь', 'они', 'тфуенбжгтаэе', 'узчг', 'уяпрбздихчъ', 'лгйрцжюпца']) == {'зэшхкхэр': 0, 'ъщнкшбжм': 1, 'агшф': 2, 'птчую': 3, 'лбфигхъймщв': 4, 'ющкйь': 5, 'они': 6, 'тфуенбжгтаэе': 7, 'узчг': 8, 'уяпрбздихчъ': 9, 'лгйрцжюпца': 10}\n       words_dictionary(array=['вгньшфбяпр', 'чрзшгасаро', 'щьырбв', 'жфг', 'рфгмьеуацй', 'ьдбринс', 'мнзиъгушаь', 'ъзьыпю']) == {'вгньшфбяпр': 0, 'чрзшгасаро': 1, 'щьырбв': 2, 'жфг': 3, 'рфгмьеуацй': 4, 'ьдбринс': 5, 'мнзиъгушаь': 6, 'ъзьыпю': 7}\n    \"\"\"",
            "tests": "[{'array': ['зэшхкхэр', 'ъщнкшбжм', 'агшф', 'птчую', 'лбфигхъймщв', 'ющкйь', 'они', 'тфуенбжгтаэе', 'узчг', 'уяпрбздихчъ', 'лгйрцжюпца']}, {'array': ['вгньшфбяпр', 'чрзшгасаро', 'щьырбв', 'жфг', 'рфгмьеуацй', 'ьдбринс', 'мнзиъгушаь', 'ъзьыпю']}, {'array': ['нуичл', 'юфкдлшзй', 'нъж', 'юзщ', 'ицщчешжзв', 'счхжржтъпуар', 'ияэьяьщ']}, {'array': ['внащьнд', 'мывблх', 'рюеь', 'аждэжгж', 'юлрилмкпк', 'сярнсшпл', 'йвая', 'ддцрмцбм', 'ъщяжхарс', 'аъйгу', 'жхцчлкл']}, {'array': ['пиря', 'ынхйыщжйън', 'хршйхзсб', 'лхчуяж', 'эцкгщыбсщшщк', 'таущзнт', 'эсигро']}, {'array': ['лдфшц', 'зршмъм', 'шзгыл', 'ревв', 'теыьп', 'щцафдщфцвжщ', 'ъаъчщтуаъч', 'ъяйпкябиуге']}, {'array': ['дкб', 'эзврцчу', 'ъюоткеьилзю', 'ксюгасъхкцдж', 'ыоюз', 'мцинчгч', 'штженайюонд', 'зчжяюф', 'хэлюды']}, {'array': ['эхюгбыэскх', 'ейеьчрвлди', 'тямьяцкацх', 'хббцащсц', 'аль', 'гнфляэмр', 'ыжцчщьюф', 'бйвбэщ']}, {'array': ['пндищнщй', 'омонфп', 'гэггчългф', 'уейябмдку', 'аофшею', 'эдпдьтяи', 'юыьбыу', 'южуфююсущ', 'зкяксьсйън', 'крйапуоцщтх', 'ююи', 'фиьйнму']}, {'array': ['глуйящ', 'цлйвешюсфкж', 'кхюо', 'дщброхз', 'попежпбчэ', 'слйеьшцщсери', 'ньпхххофьпх', 'лчеэшяндечр', 'бввящшвэй', 'шдслуию', 'гфвдч', 'кдгя', 'юфулэзп']}]"
        },
        "outputs": [
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ],
        "meta": {
            "id": 93,
            "canonical_solution": "",
            "entry_point": "words_dictionary"
        }
    },
    "5": {
        "instruction": "Дано описание функции, напиши программу на языке Python\n{function}",
        "inputs": {
            "function": "from typing import List\n\n\ndef same_quarter(coordinatesA: List[int], coordinatesB: List[int]) -> str:\n    \"\"\"На основании списка координат coordinatesA первой точки и списка координат coordinatesB второй точки, определите, лежат ли они в одной четверти декартовой системы координат. Если лежат, выведите \"Да\", если не лежат - \"Нет\".\n    Примеры:\n       same_quarter(coordinatesA=[5, 2941], coordinatesB=[9391, 7]) == 'Да'\n       same_quarter(coordinatesA=[7801, 99], coordinatesB=[65, -547]) == 'Нет'\n    \"\"\"",
            "tests": "[{'coordinatesA': [5, 2941], 'coordinatesB': [9391, 7]}, {'coordinatesA': [7801, 99], 'coordinatesB': [65, -547]}, {'coordinatesA': [23, -1594], 'coordinatesB': [31, 1810]}, {'coordinatesA': [1361, -9115], 'coordinatesB': [3174, -2099]}, {'coordinatesA': [57, -450], 'coordinatesB': [-66, 2581]}, {'coordinatesA': [7278, -4977], 'coordinatesB': [-4955, -5038]}, {'coordinatesA': [-767, 6064], 'coordinatesB': [62, -36]}, {'coordinatesA': [-8678, 4798], 'coordinatesB': [-4602, 9514]}, {'coordinatesA': [-19, 11], 'coordinatesB': [-5209, -9375]}, {'coordinatesA': [-1141, -4], 'coordinatesB': [-4194, -1]}]"
        },
        "outputs": [
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ],
        "meta": {
            "id": 5,
            "canonical_solution": "",
            "entry_point": "same_quarter"
        }
    },
    "103": {
        "instruction": "Необходимо реализовать логику на языке Python для следующей программы\n{function}",
        "inputs": {
            "function": "def topk_words(string: str, number: int) -> str:\n    \"\"\"В строке string все слова разделены пробелами. Выведите новую строку, которая содержит только первые number слов изначальной строки.\n    Примеры:\n       topk_words(string=Призрак такого сима получает ту же смертельную черту, что и пожилые симы, умершие от физических нагрузок, и ничем не отличается, number=16) == 'Призрак такого сима получает ту же смертельную черту, что и пожилые симы, умершие от физических нагрузок,'\n       topk_words(string=В эту игру можно играть по самым разным сценариям, number=2) == 'В эту'\n    \"\"\"",
            "tests": "[{'string': 'Призрак такого сима получает ту же смертельную черту, что и пожилые симы, умершие от физических нагрузок, и ничем не отличается', 'number': 16}, {'string': 'В эту игру можно играть по самым разным сценариям', 'number': 2}, {'string': 'Однако иногда красота может оказаться не преимуществом, а препятствием', 'number': 4}, {'string': 'Даже всемогущая пунктуация не имеет власти над рыбными текстами, ведущими безорфографичный образ жизни', 'number': 4}, {'string': 'Например, гриль или плита, размещённые на ковровом покрытии, готовка на дешевой плите, а также низкий навык кулинарии или выпечки', 'number': 11}, {'string': 'Поедем туда на следующий год и будем там вовсю бросаться помидорами', 'number': 10}, {'string': 'В мире соулмейтов, каждый находит свою пару по фобии, приобретённой с рождения', 'number': 4}, {'string': 'Пожилым персонажам стоит воздерживаться от чрезмерных физических нагрузок и активного вуху, чтобы не получить перенапряжение', 'number': 10}, {'string': 'Моя сестра тратит деньги просто так', 'number': 5}, {'string': 'Моя девушка гуляет просто так', 'number': 2}]"
        },
        "outputs": [
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ],
        "meta": {
            "id": 103,
            "canonical_solution": "",
            "entry_point": "topk_words"
        }
    },
    "33": {
        "instruction": "Необходимо реализовать логику на языке Python для следующей программы\n{function}",
        "inputs": {
            "function": "def fibonacci_strings(number: int) -> str:\n    \"\"\"Вам дано положительное число number, которому соответствует строка. Выведите ее. Строки для числа строятся следующим образом: если number равен 1, то строка равна \"a\", если number равен 2, то строка равна \"b\", а для всех number больше 2 строка является конкатенацией строк с номерами (number - 2) и (number - 1). Гарантируется, что number не превосходит 10.\n    Примеры:\n       fibonacci_strings(number=1) == 'a'\n       fibonacci_strings(number=2) == 'b'\n    \"\"\"",
            "tests": "[{'number': 1}, {'number': 2}, {'number': 3}, {'number': 4}, {'number': 5}, {'number': 6}, {'number': 7}, {'number': 8}, {'number': 9}, {'number': 10}]"
        },
        "outputs": [
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ],
        "meta": {
            "id": 33,
            "canonical_solution": "",
            "entry_point": "fibonacci_strings"
        }
    },
    "77": {
        "instruction": "По данному условию с фиксированной шапкой функции(ий) напиши программу\n{function}",
        "inputs": {
            "function": "from typing import List\n\n\ndef array_search(array: List[int], number: int) -> int:\n    \"\"\"Если число number встречается в списке array, который отсортирован в порядке неубывания, выведите число 1, иначе выведите число 0.\n    Примеры:\n       array_search(array=[-8, -7, -3, -3, -2, 6, 9, 10, 11, 11, 12, 16], number=0) == 0\n       array_search(array=[-10, -8, 0, 1, 3, 3, 8, 9, 10, 11, 13, 17, 19], number=13) == 1\n    \"\"\"",
            "tests": "[{'array': [-8, -7, -3, -3, -2, 6, 9, 10, 11, 11, 12, 16], 'number': 0}, {'array': [-10, -8, 0, 1, 3, 3, 8, 9, 10, 11, 13, 17, 19], 'number': 13}, {'array': [-10, -9, -6, -2, 2, 5, 9, 12, 12, 13, 14], 'number': -8}, {'array': [-9, -5, -2, 4, 15], 'number': 0}, {'array': [-10, -9, 5, 5, 7, 8, 8, 10, 11, 12, 13], 'number': 12}, {'array': [-7, -2, 0, 2, 5, 5, 10, 12, 12, 13, 15], 'number': 5}, {'array': [-1, 1, 4, 5, 6, 9, 11, 11, 13, 14], 'number': 8}, {'array': [-8, -5, -3, -3, 5, 5, 10, 12, 14, 15, 17], 'number': 2}, {'array': [-7, 1, 8, 10, 14], 'number': 4}, {'array': [-8, -6, -4, -3, -3, -2, 1, 2, 6, 7, 7, 14, 17, 18], 'number': 1}]"
        },
        "outputs": [
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ],
        "meta": {
            "id": 77,
            "canonical_solution": "",
            "entry_point": "array_search"
        }
    },
    "44": {
        "instruction": "Допишите код на языке Python в соответствии с условием, приведенным в описании\n{function}",
        "inputs": {
            "function": "def find_missing(string: str, shuffle: str) -> str:\n    \"\"\"Вам даны оригинальная строка string и измененная строка shuffle, которая получена случайным перемешиванием символов строки string с добавлением одного дополнительного символа. Выведите добавленный к shuffle символ.\n    Примеры:\n       find_missing(string=заполучить, shuffle=пзуичлтоаьз) == 'з'\n       find_missing(string=жаловаться, shuffle=ясвлоатаьжь) == 'ь'\n    \"\"\"",
            "tests": "[{'string': 'заполучить', 'shuffle': 'пзуичлтоаьз'}, {'string': 'жаловаться', 'shuffle': 'ясвлоатаьжь'}, {'string': 'пересолить', 'shuffle': 'силетепьоро'}, {'string': 'подержание', 'shuffle': 'жрианопедеш'}, {'string': 'работаться', 'shuffle': 'ааятсртьобщ'}, {'string': 'столешница', 'shuffle': 'аиолнтешцст'}, {'string': 'тюркология', 'shuffle': 'оюокияртглч'}, {'string': 'привернуть', 'shuffle': 'рептинвьурд'}, {'string': 'протерпеть', 'shuffle': 'еотпьрептрш'}, {'string': 'бортпроводник', 'shuffle': 'орокдтпбвиорнк'}]"
        },
        "outputs": [
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ],
        "meta": {
            "id": 44,
            "canonical_solution": "",
            "entry_point": "find_missing"
        }
    },
    "135": {
        "instruction": "Дано описание функции, напиши программу на языке Python\n{function}",
        "inputs": {
            "function": "def minimum_split(number: int) -> int:\n    \"\"\"Разделите цифры целого числа number на два отдельных числа так, чтобы сумма этих чисел была минимально возможной. Выведите полученную сумму данных чисел. Гарантируется, что number не меньше 10.\n    Примеры:\n       minimum_split(number=45) == 9\n       minimum_split(number=192) == 21\n    \"\"\"",
            "tests": "[{'number': 45}, {'number': 192}, {'number': 843}, {'number': 1230}, {'number': 273}, {'number': 876543}, {'number': 10}, {'number': 219}, {'number': 327}, {'number': 49729}]"
        },
        "outputs": [
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ],
        "meta": {
            "id": 135,
            "canonical_solution": "",
            "entry_point": "minimum_split"
        }
    },
    "45": {
        "instruction": "Дано описание функции, напиши программу на языке Python\n{function}",
        "inputs": {
            "function": "from typing import List\n\n\ndef arithmetic_mean(array: List[int]) -> float:\n    \"\"\"Дан массив из чисел array. Найдите среднее арифметическое данного массива. Среднее арифметическое массива чисел равно сумме всех чисел массива, поделенной на количество чисел в массиве. Гарантируется, что массив имеет хотя бы один элемент. Выведите получившееся число, округленное до 2 знаков после запятой.\n    Примеры:\n       arithmetic_mean(array=[68, -65, 7, -8, -88, 80, 23, -72, 65]) == 1.11\n       arithmetic_mean(array=[-15, 2, -28, -20, -8, -81, -87, 78, 68, -5]) == -9.6\n    \"\"\"",
            "tests": "[{'array': [68, -65, 7, -8, -88, 80, 23, -72, 65]}, {'array': [-15, 2, -28, -20, -8, -81, -87, 78, 68, -5]}, {'array': [9, 6, 14, 56, 95, 13, 84, -40, 90, 23, -87]}, {'array': [46, -73, 67, 29, 20, 41, 12, 7, 43]}, {'array': [-12, -34, 39, 56, 74, -96, 63]}, {'array': [36, 32, 10, -96, 69, -48, -64, 5, -53, -57]}, {'array': [-91, -13, -15, 25, -53, 58, 88, -93, -67, 2]}, {'array': [15, 27, 35, 70, 91, 77, 5, -51, 44, 44, -30, -60]}, {'array': [-90, 0, -15, -85, -29, 81, -66, -42]}, {'array': [42, -75, 69, 39, 58, -68, -54, -77, 4, -89, -87, 97, 24]}]"
        },
        "outputs": [
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ],
        "meta": {
            "id": 45,
            "canonical_solution": "",
            "entry_point": "arithmetic_mean"
        }
    },
    "12": {
        "instruction": "Напишите программу по строке документации\n{function}",
        "inputs": {
            "function": "def sum_squares(number: int) -> int:\n    \"\"\"Дано натуральное число number. Выведите сумму квадратов всех натуральных чисел до number включительно. Гарантируется, что number не превосходит 100.\n    Примеры:\n       sum_squares(number=66) == 98021\n       sum_squares(number=58) == 66729\n    \"\"\"",
            "tests": "[{'number': 66}, {'number': 58}, {'number': 30}, {'number': 8}, {'number': 17}, {'number': 2}, {'number': 88}, {'number': 5}, {'number': 51}, {'number': 6}]"
        },
        "outputs": [
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ],
        "meta": {
            "id": 12,
            "canonical_solution": "",
            "entry_point": "sum_squares"
        }
    },
    "97": {
        "instruction": "По данному условию с фиксированной шапкой функции(ий) напиши программу\n{function}",
        "inputs": {
            "function": "def unique_frequency(string: str) -> str:\n    \"\"\"Дана строка string. Определите, одинаково ли число вхождений в строку для каждого уникального символа из string. Выведите \"Да\", если одинаково. Иначе, выведите \"Нет\".\n    Примеры:\n       unique_frequency(string=шаллаш) == 'Да'\n       unique_frequency(string=аффирмации) == 'Нет'\n    \"\"\"",
            "tests": "[{'string': 'шаллаш'}, {'string': 'аффирмации'}, {'string': 'йвоюфациылрм'}, {'string': 'лвопаицрмф'}, {'string': 'йдмыфпуицаов'}, {'string': 'алюфвойуцмп'}, {'string': 'вомрафыцйл'}, {'string': 'выйооцдййлмалурылфйлффаююроццавуювыиу'}, {'string': 'ыырювувюиюрфропыыфуиповммпоуриыацлыицаыйирццв'}, {'string': 'ппайфлиавапдмвмцвмпйдфуоююыицувфю'}]"
        },
        "outputs": [
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ],
        "meta": {
            "id": 97,
            "canonical_solution": "",
            "entry_point": "unique_frequency"
        }
    },
    "149": {
        "instruction": "Дан шаблон функции(ий) с описанием работы этой функции в качестве условия задачи. Допишите программу\n{function}",
        "inputs": {
            "function": "from typing import List\n\n\ndef concatenation_maximum(array: List[int]) -> str:\n    \"\"\"Выведите строку, которая содержит максимально возможное число, которое можно получить конкатенацией чисел из списка array. Гарантируется, что в списке более 1 элемента.\n    Примеры:\n       concatenation_maximum(array=[1, 3, 1, 7]) == '7311'\n       concatenation_maximum(array=[6, 6, 1, 2, 6]) == '66621'\n    \"\"\"",
            "tests": "[{'array': [1, 3, 1, 7]}, {'array': [6, 6, 1, 2, 6]}, {'array': [6, 3, 4, 5, 3]}, {'array': [9, 3, 7, 1]}, {'array': [7, 5, 9, 7, 5]}, {'array': [1, 9, 3, 8, 1]}, {'array': [6, 1, 6, 4, 3]}, {'array': [4, 8, 4, 3, 8, 6]}, {'array': [7, 4, 8, 3, 9]}, {'array': [9, 3, 7, 8]}]"
        },
        "outputs": [
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ],
        "meta": {
            "id": 149,
            "canonical_solution": "",
            "entry_point": "concatenation_maximum"
        }
    },
    "156": {
        "instruction": "На вход подается функция(ии) с описанием в виде строки docstring. В соответствии с описанием вам необходимо реализовать функцию(ии)\n{function}",
        "inputs": {
            "function": "def reach_number(number: int) -> str:\n    \"\"\"Определите, можно ли из точки 0 координатной прямой попасть в точку number, если разрешается сделать любое количество действий. В одном действии разрешается прибавить к текущей координате номер действия иил вычесть его. Если да, выведите минимальное количество действий, необходимое для попадания в точку number из точки 0. Если нет, выведите -1.\n    Примеры:\n       reach_number(number=1) == 1\n       reach_number(number=192) == 20\n    \"\"\"",
            "tests": "[{'number': 1}, {'number': 192}, {'number': 843}, {'number': 1230}, {'number': 49}, {'number': 8763}, {'number': 8}, {'number': 219}, {'number': 288}, {'number': 4979}]"
        },
        "outputs": [
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ],
        "meta": {
            "id": 156,
            "canonical_solution": "",
            "entry_point": "reach_number"
        }
    },
    "86": {
        "instruction": "На вход подается функция(ии) с описанием в виде строки docstring. В соответствии с описанием вам необходимо реализовать функцию(ии)\n{function}",
        "inputs": {
            "function": "from typing import List\n\n\ndef double_zeros(array: List[int]) -> int:\n    \"\"\"В списке array перенесите все ненулевые элементы в конец списка в порядке их появления в списке, а количество нулей в начале списка удвойте. Выведите сумму полученного списка с 0 индекса до индекса длины изначального списка. Если список пуст, выведите 0. Если в исходном списке нет нулей, ответом будет сумма всех элементов списка.\n    Примеры:\n       double_zeros(array=[0, 0, 2, 0, 0, 3]) == 5\n       double_zeros(array=[4, 4, 2, 0, 0, 0, 0, 4, 3, 0, 0]) == 17\n    \"\"\"",
            "tests": "[{'array': [0, 0, 2, 0, 0, 3]}, {'array': [4, 4, 2, 0, 0, 0, 0, 4, 3, 0, 0]}, {'array': [1, 1, 2, 4, 2, 1]}, {'array': [1, 4, 3, 1, 2, 0, 0, 4, 1]}, {'array': [0, 0, 3, 2, 3, 1]}, {'array': [0, 0, 0, 0, 3, 1, 1, 4, 4]}, {'array': [2, 1, 2, 2, 4, 4, 4, 4, 0, 0, 4, 3, 0, 0]}, {'array': [4, 4, 2, 4, 4, 2, 3]}, {'array': []}, {'array': [0, 0, 0, 0, 0, 0]}]"
        },
        "outputs": [
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ],
        "meta": {
            "id": 86,
            "canonical_solution": "",
            "entry_point": "double_zeros"
        }
    },
    "148": {
        "instruction": "Необходимо написать код по условию из строковой переменной документации, следующей после функции(ий)\n{function}",
        "inputs": {
            "function": "from typing import List\n\n\ndef h_index(array: List[int]) -> int:\n    \"\"\"Список array содержит количества цитирований каждой из работ ученого. Выведите H-индекс ученого. H-индекс является такой максимально возможной величиной, что существует не меньше H работ ученого, которые были процитированы не менее H раз. Гарантируется, что массив содержит не менее 1 ненулевого элемента.\n    Примеры:\n       h_index(array=[3, 3, 5, 5, 8, 8, 8, 9, 10, 10, 10, 11, 12, 12, 14]) == 8\n       h_index(array=[1, 3, 4, 5, 5, 5, 5, 8, 9, 12, 14, 14]) == 5\n    \"\"\"",
            "tests": "[{'array': [3, 3, 5, 5, 8, 8, 8, 9, 10, 10, 10, 11, 12, 12, 14]}, {'array': [1, 3, 4, 5, 5, 5, 5, 8, 9, 12, 14, 14]}, {'array': [1]}, {'array': [3, 9, 9, 9, 10, 11, 11, 11, 11, 12, 12, 12, 13]}, {'array': [2, 3, 3, 3, 4, 4, 4, 5, 6, 9, 12, 13, 13, 14]}, {'array': [1, 1, 2, 2, 6, 8, 8, 9, 10, 12, 13, 14]}, {'array': [1, 3, 6, 6, 9, 10, 10, 11, 11, 12]}, {'array': [2, 2, 4, 8, 8, 12, 13, 14]}, {'array': [1, 3, 4, 5, 5, 8, 8, 9, 10, 10, 10, 12, 13, 13]}, {'array': [2, 4, 4, 8, 10, 12, 12, 13]}]"
        },
        "outputs": [
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ],
        "meta": {
            "id": 148,
            "canonical_solution": "",
            "entry_point": "h_index"
        }
    },
    "39": {
        "instruction": "Дан шаблон функции(ий) с описанием работы этой функции в качестве условия задачи. Допишите программу\n{function}",
        "inputs": {
            "function": "def sum_closest(number: int) -> int:\n    \"\"\"Дано натуральное число number. Выведите сумму следующего за ним числа и предыдущего.\n    Примеры:\n       sum_closest(number=2) == 4\n       sum_closest(number=28) == 56\n    \"\"\"",
            "tests": "[{'number': 2}, {'number': 28}, {'number': 387}, {'number': 1234}, {'number': 3568}, {'number': 876543}, {'number': 13}, {'number': 927}, {'number': 1453}, {'number': 98376}]"
        },
        "outputs": [
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ],
        "meta": {
            "id": 39,
            "canonical_solution": "",
            "entry_point": "sum_closest"
        }
    },
    "138": {
        "instruction": "Необходимо написать код по условию из строковой переменной документации, следующей после функции(ий)\n{function}",
        "inputs": {
            "function": "from typing import List\n\n\ndef find_minimum(array1: List[int], array2: List[int]) -> int:\n    \"\"\"Выведите число, минимальное одновременно для двух массивов array1 и array2, отсортированных в порядке неубывания. Число должно встречаться как в первом массиве, так и во втором. Если такого числа нет или хотя бы один из массивов пуст, выведите \"-1\".\n    Примеры:\n       find_minimum(array1=[7, 11, 17, 21, 24, 24], array2=[7, 10, 12, 16, 20]) == 7\n       find_minimum(array1=[4, 5, 7, 11, 15, 16, 21], array2=[4, 7, 10, 14, 15, 15, 17, 18, 19, 22]) == 4\n    \"\"\"",
            "tests": "[{'array1': [7, 11, 17, 21, 24, 24], 'array2': [7, 10, 12, 16, 20]}, {'array1': [4, 5, 7, 11, 15, 16, 21], 'array2': [4, 7, 10, 14, 15, 15, 17, 18, 19, 22]}, {'array1': [], 'array2': []}, {'array1': [23], 'array2': []}, {'array1': [1, 6, 8, 12, 15, 16, 22], 'array2': [1, 1, 5, 7, 8, 11, 15, 18, 19, 23]}, {'array1': [22], 'array2': [22]}, {'array1': [2, 3, 5, 10, 15, 16, 20, 22, 22, 23], 'array2': [2, 3, 3, 9, 13, 22]}, {'array1': [5, 7, 10, 11, 13, 15, 23], 'array2': [5, 9, 9, 13, 13, 15, 23, 23]}, {'array1': [6, 12, 12, 13, 14, 22, 24], 'array2': [6, 6, 8, 13, 14, 15, 19, 19, 21]}, {'array1': [], 'array2': [7, 11, 11, 14, 19]}]"
        },
        "outputs": [
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ],
        "meta": {
            "id": 138,
            "canonical_solution": "",
            "entry_point": "find_minimum"
        }
    },
    "87": {
        "instruction": "По данному условию с фиксированной шапкой функции(ий) напиши программу\n{function}",
        "inputs": {
            "function": "def delete_primitives(string: str) -> int:\n    \"\"\"Минимальная корректная скобочная последовательность (состоит из двух скобок), называется примитивом. Удалите из строки со скобочной последовательностью string все примитивы. Если при удалении примитивов возникают новые примитивы, их тоже нужно удалить. Выведите длину оставшейся после удаления всех возможных примитивов строки. Скобки могут быть трех видов: круглые, квадратные и фигурные - данные виды скобок не взимозаменяемы и независимы друг от друга.\n    Примеры:\n       delete_primitives(string=[ ] [ ] [ ] [ ] ( [ ] { } ) ( { } ( ) )) == 0\n       delete_primitives(string=} { ( ] [ { [ ( ) ) ( )) == 8\n    \"\"\"",
            "tests": "[{'string': '[ ] [ ] [ ] [ ] ( [ ] { } ) ( { } ( ) )'}, {'string': '} { ( ] [ { [ ( ) ) ( )'}, {'string': '[ ] [ ] [ ] [ { } ] ( { ( [ ] ( ) ) } )'}, {'string': '{ ) } ( [ ] ) [ ) } ] )'}, {'string': ') [ ] ) { { ] ( [ [ } { ( ( { ] } } ) )'}, {'string': '[ ] [ ] [ ] [ ] ( ) { { ( ) ( ) } } { }'}, {'string': '[ [ ( ) { } ] ]'}, {'string': '[ { [ } { { ] ] ) ( } )'}, {'string': '( [ ] ) ( { [ ] } { } )'}, {'string': '[ ] [ ] [ ] [ { } ( { } { } ) ] { [ ] }'}]"
        },
        "outputs": [
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ],
        "meta": {
            "id": 87,
            "canonical_solution": "",
            "entry_point": "delete_primitives"
        }
    },
    "152": {
        "instruction": "Напишите программу по строке документации\n{function}",
        "inputs": {
            "function": "from typing import List\n\n\ndef change_sort(array: List[int]) -> str:\n    \"\"\"Определите, возможно ли сделать список array отсортированным в неубывающем порядке путем изменения только одного элемента списка. Если возможно, выведите \"Да\", иначе – \"Нет\". Пустой список отсортировать невозможно.\n    Примеры:\n       change_sort(array=[-5, 16, 44, 44, -57, -92, 18, -30, -33, 8, 7]) == 'Нет'\n       change_sort(array=[-98, -79, -78, -48, -20, 18, 33, 28, 31, 77]) == 'Да'\n    \"\"\"",
            "tests": "[{'array': [-5, 16, 44, 44, -57, -92, 18, -30, -33, 8, 7]}, {'array': [-98, -79, -78, -48, -20, 18, 33, 28, 31, 77]}, {'array': [-90, -86, -83, -29, 23, 31, 36, 40, 52, 52, 65]}, {'array': [-76, -42, -59, 73, 36, -59, 93, -93, 30, -45]}, {'array': [-74, -40, -5, 5, 9, 31, 37, 50, 50, 83]}, {'array': [-96, -75, -75, -36, -35, -35, 1, 94, 12, 77]}, {'array': [-84, -48, -13, -8, -12, 10, 56, 66, 95, 99]}, {'array': [-62, -50, -41, -11, 28, 42, 66, 71, 71, 95]}, {'array': [85, -75, 43, -18, -40, -27, 82, 2, 19, 74, -20, -64, 44]}, {'array': []}]"
        },
        "outputs": [
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ],
        "meta": {
            "id": 152,
            "canonical_solution": "",
            "entry_point": "change_sort"
        }
    },
    "40": {
        "instruction": "Реши задачу по программированию\n{function}",
        "inputs": {
            "function": "def find_distance(speed: int, length: int, time: int) -> int:\n    \"\"\"Велосипедист начал движение по кольцевой трассе со скоростью speed километров в час. Длина трассы составляет length километров. На какой отметке трассы остановится велосипедист через time часов? После того, как велосипедист проедет всю трассу, он попадет снова на отметку 0 километров и начнет проезжать трассу заново. Выведите получившееся число.\n    Примеры:\n       find_distance(speed=3, length=3, time=2) == 0\n       find_distance(speed=50, length=51, time=1) == 50\n    \"\"\"",
            "tests": "[{'speed': 3, 'length': 3, 'time': 2}, {'speed': 50, 'length': 51, 'time': 1}, {'speed': 10, 'length': 23, 'time': 1}, {'speed': 33, 'length': 66, 'time': 222}, {'speed': 22, 'length': 20, 'time': 12}, {'speed': 2, 'length': 3, 'time': 5}, {'speed': 2, 'length': 5, 'time': 2}, {'speed': 3, 'length': 22, 'time': 7}, {'speed': 10, 'length': 6, 'time': 9}, {'speed': 300, 'length': 505, 'time': 610}]"
        },
        "outputs": [
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ],
        "meta": {
            "id": 40,
            "canonical_solution": "",
            "entry_point": "find_distance"
        }
    },
    "1": {
        "instruction": "Реализуй функцию(ии) на языке Python\n{function}",
        "inputs": {
            "function": "def sum_digits(number: int) -> int:\n    \"\"\"Выведите сумму цифр натурального числа number.\n    Примеры:\n       sum_digits(number=1) == 1\n       sum_digits(number=10) == 1\n    \"\"\"",
            "tests": "[{'number': 1}, {'number': 10}, {'number': 23}, {'number': 123456}, {'number': 666}, {'number': 409}, {'number': 81}, {'number': 42587}, {'number': 987346}, {'number': 1987347}]"
        },
        "outputs": [
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ],
        "meta": {
            "id": 1,
            "canonical_solution": "",
            "entry_point": "sum_digits"
        }
    },
    "71": {
        "instruction": "Реализуй функцию(ии) на языке Python\n{function}",
        "inputs": {
            "function": "def build_ladder(number: int) -> int:\n    \"\"\"Лестницы строится из кирпичей. Каждый новый уровень лестницы требует количества кирпичей, которое равно порядковому уровню лестницы, начиная с 1. Последний этаж летницы может быть не достроен. Выведите, сколько полных этажей лестницы можно построить из number кирпичей.\n    Примеры:\n       build_ladder(number=2) == 1\n       build_ladder(number=28) == 7\n    \"\"\"",
            "tests": "[{'number': 2}, {'number': 28}, {'number': 387}, {'number': 1234}, {'number': 3568}, {'number': 876543}, {'number': 6}, {'number': 496}, {'number': 8128}, {'number': 98376}]"
        },
        "outputs": [
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ],
        "meta": {
            "id": 71,
            "canonical_solution": "",
            "entry_point": "build_ladder"
        }
    },
    "114": {
        "instruction": "Допишите код на языке Python в соответствии с условием, приведенным в описании\n{function}",
        "inputs": {
            "function": "from typing import List\n\n\ndef frequeny_sort(array: List[int]) -> List[int]:\n    \"\"\"Отсортируйте список целых чисел array в порядке возрастания частоты появления элементов в списке. Элементы с одинаковой частотой отсортируйте по убыванию значения. Выведите получившийся список.\n    Примеры:\n       frequeny_sort(array=[18, 18, 3, 8, 12, 7, 15, 6, 2, 2, 14]) == [15, 14, 12, 8, 7, 6, 3, 18, 18, 2, 2]\n       frequeny_sort(array=[9, 12, 17, 0, 9, 4, 10, 4, 9]) == [17, 12, 10, 0, 4, 4, 9, 9, 9]\n    \"\"\"",
            "tests": "[{'array': [18, 18, 3, 8, 12, 7, 15, 6, 2, 2, 14]}, {'array': [9, 12, 17, 0, 9, 4, 10, 4, 9]}, {'array': [15, 9, 2, 3, 3]}, {'array': [7, 3, 15, 3, 11]}, {'array': [2, 7, 3, 15, 6, 3]}, {'array': [11, 1, 18, 18, 15, 14, 17, 16, 13, 6]}, {'array': [15, 9, 11, 10, 9, 16, 8, 19, 0, 10, 13]}, {'array': [3, 15, 7, 19, 11, 11, 3, 13, 12, 13, 13, 10]}, {'array': [6, 16, 7, 9, 5, 13, 11, 18, 5, 12, 0, 15, 9, 16]}, {'array': [5, 11, 19, 8, 12, 1, 7]}]"
        },
        "outputs": [
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ],
        "meta": {
            "id": 114,
            "canonical_solution": "",
            "entry_point": "frequeny_sort"
        }
    },
    "56": {
        "instruction": "На вход подается функция(ии) с описанием в виде строки docstring. В соответствии с описанием вам необходимо реализовать функцию(ии)\n{function}",
        "inputs": {
            "function": "def formate_date(date: dict) -> str:\n    \"\"\"Дан словарь date, содержащий дату. Ключи словаря: год, месяц, день. Приведите дату к формату \"YY-MM-DD\" и выведите получившуюся строку. Если число дней или номер месяца являются однозначным числом, дополните такое число слева нулем.\n    Примеры:\n       formate_date(date={'год': 2023, 'месяц': 3, 'день': 12}) == '23-03-12'\n       formate_date(date={'год': 1989, 'месяц': 1, 'день': 17}) == '89-01-17'\n    \"\"\"",
            "tests": "[{'date': {'год': 2023, 'месяц': 3, 'день': 12}}, {'date': {'год': 1989, 'месяц': 1, 'день': 17}}, {'date': {'год': 1990, 'месяц': 8, 'день': 14}}, {'date': {'год': 1918, 'месяц': 1, 'день': 27}}, {'date': {'год': 1914, 'месяц': 9, 'день': 6}}, {'date': {'год': 2004, 'месяц': 1, 'день': 11}}, {'date': {'год': 1921, 'месяц': 9, 'день': 22}}, {'date': {'год': 1936, 'месяц': 12, 'день': 28}}, {'date': {'год': 1909, 'месяц': 9, 'день': 27}}, {'date': {'год': 2019, 'месяц': 3, 'день': 3}}]"
        },
        "outputs": [
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ],
        "meta": {
            "id": 56,
            "canonical_solution": "",
            "entry_point": "formate_date"
        }
    },
    "107": {
        "instruction": "По данному условию с фиксированной шапкой функции(ий) напиши программу\n{function}",
        "inputs": {
            "function": "def contiguous_ones(string: str) -> str:\n    \"\"\"Если строка string из 0 и 1 содержит непрерывную подследовательность из 1 длиной больше 1, то выведите \"Да\". Иначе, выведите \"Нет\".\n    Примеры:\n       contiguous_ones(string=1111110) == 'Да'\n       contiguous_ones(string=11100011) == 'Нет'\n    \"\"\"",
            "tests": "[{'string': '1111110'}, {'string': '11100011'}, {'string': '1100000'}, {'string': '1111000'}, {'string': '11100000'}, {'string': '101110100'}, {'string': '11000110'}, {'string': '011000011'}, {'string': '0000000'}, {'string': '010011010'}]"
        },
        "outputs": [
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ],
        "meta": {
            "id": 107,
            "canonical_solution": "",
            "entry_point": "contiguous_ones"
        }
    },
    "155": {
        "instruction": "Дано описание функции, напиши программу на языке Python\n{function}",
        "inputs": {
            "function": "def complex_product(string1: str, string2: str) -> str:\n    \"\"\"Даны две строки string1 и string2, которые содержат по одному комплексному числу. Комплексные числа — это числа вида a + b i , где a , b — вещественные числа, i — мнимая единица, то есть число, для которого выполняется равенство: i^2 = − 1. Проведите умножение данных комплексных чисел и выведите получившееся число в виде строки с аналогичным форматированием.\n    Примеры:\n       complex_product(string1=15+72i, string2=-30+-36i) == '2142-2700i'\n       complex_product(string1=53+-78i, string2=86+50i) == '8458-4058i'\n    \"\"\"",
            "tests": "[{'string1': '15+72i', 'string2': '-30+-36i'}, {'string1': '53+-78i', 'string2': '86+50i'}, {'string1': '14+-95i', 'string2': '-10+1i'}, {'string1': '-77+69i', 'string2': '73+-41i'}, {'string1': '58+85i', 'string2': '80+-45i'}, {'string1': '-80+28i', 'string2': '74+18i'}, {'string1': '57+-63i', 'string2': '-73+6i'}, {'string1': '-61+-4i', 'string2': '28+-92i'}, {'string1': '91+-20i', 'string2': '-15+49i'}, {'string1': '-73+35i', 'string2': '-91+-84i'}]"
        },
        "outputs": [
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ],
        "meta": {
            "id": 155,
            "canonical_solution": "",
            "entry_point": "complex_product"
        }
    },
    "50": {
        "instruction": "Реши задачу по программированию\n{function}",
        "inputs": {
            "function": "from typing import List\n\n\ndef minimum_shift(array: List[int]) -> int:\n    \"\"\"Дан массив натуральных чисел array. Сколько циклических сдвигов вправо нужно сделать в данном массиве, чтобы он стал отсортированным? Выведите получившееся число. Если сдвигами отсортировать массив невозможно, то выведите \"-1\".\n    Примеры:\n       minimum_shift(array=[14, 3, 12, 13, 14]) == 4\n       minimum_shift(array=[9, 9, 8, 3, 1, 7, 6, 4, 6, 6, 5]) == -1\n    \"\"\"",
            "tests": "[{'array': [14, 3, 12, 13, 14]}, {'array': [9, 9, 8, 3, 1, 7, 6, 4, 6, 6, 5]}, {'array': [1, 2, 11, 12, 12]}, {'array': [9, 5, 4, 9, 4, 3, 8, 7, 5, 3, 7, 2, 9, 9]}, {'array': [14, 3, 4, 8, 10]}, {'array': [7, 9, 7, 5, 8, 1, 1, 5, 7]}, {'array': [9, 6, 3, 1, 3, 8, 1, 1, 3, 4, 7, 8, 9, 5]}, {'array': [4, 5, 9, 13, 1]}, {'array': [8, 9, 13, 3, 6, 6]}, {'array': [1, 4, 7, 10, 12]}]"
        },
        "outputs": [
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ],
        "meta": {
            "id": 50,
            "canonical_solution": "",
            "entry_point": "minimum_shift"
        }
    },
    "143": {
        "instruction": "Необходимо реализовать логику на языке Python для следующей программы\n{function}",
        "inputs": {
            "function": "from typing import List\n\n\ndef selective_mean(array: List[int]) -> int:\n    \"\"\"Выведите среднее арифметическое всех четных чисел списка array, которые делятся на 3. Выведите ответ в виде целого числа. Если число получается нецелым, отбросьте его дробную часть. Для пустого списка выведите 0. Среднее арифметическое массива чисел равно сумме всех чисел массива, поделенной на количество чисел в массиве.\n    Примеры:\n       selective_mean(array=[9, 10, 3, 1, 3, 14, 12, 10]) == 12\n       selective_mean(array=[]) == 0\n    \"\"\"",
            "tests": "[{'array': [9, 10, 3, 1, 3, 14, 12, 10]}, {'array': []}, {'array': [7, 10, 4, 5, 9, 12, 5]}, {'array': [7, 3, 9, 9, 6, 11, 7, 11]}, {'array': [6, 11, 9, 5, 5, 5, 7]}, {'array': [1, 6, 7, 4, 10, 14]}, {'array': [5, 4, 13, 11, 1, 3, 10, 6, 2, 12, 2]}, {'array': [11, 3, 7, 14, 2]}, {'array': [14, 9, 14, 9, 7, 4, 10, 1, 9]}, {'array': [9, 9, 12, 6, 3, 4]}]"
        },
        "outputs": [
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ],
        "meta": {
            "id": 143,
            "canonical_solution": "",
            "entry_point": "selective_mean"
        }
    },
    "161": {
        "instruction": "Реализуй функцию(ии) на языке Python\n{function}",
        "inputs": {
            "function": "def maximum_insert(number: int, string: str) -> str:\n    \"\"\"Дана строка string, которая содержит целое число, а также цифра number. Вставьте цифру number на какую-либо позицию в строке string так, чтобы число в строке string стало максимально возможным. Запрещено вставлять number перед отрицательным знаком. Выведите полученную строку, удалив ведущие нули в числе, если они есть.\n    Примеры:\n       maximum_insert(number=5, string=10) == '510'\n       maximum_insert(number=5, string=7909) == '79509'\n    \"\"\"",
            "tests": "[{'number': 5, 'string': '10'}, {'number': 5, 'string': '7909'}, {'number': 8, 'string': '4622'}, {'number': 2, 'string': '3149'}, {'number': 5, 'string': '-884'}, {'number': 9, 'string': '6657'}, {'number': 7, 'string': '5992'}, {'number': 4, 'string': '9241'}, {'number': 7, 'string': '-11'}, {'number': 0, 'string': '-1'}]"
        },
        "outputs": [
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ],
        "meta": {
            "id": 161,
            "canonical_solution": "",
            "entry_point": "maximum_insert"
        }
    },
    "129": {
        "instruction": "Дан шаблон функции(ий) с описанием работы этой функции в качестве условия задачи. Допишите программу\n{function}",
        "inputs": {
            "function": "def truncate_number(string: str) -> str:\n    \"\"\"Удалите все нули в конце числа данного на вход в формате строки string и выведите полученное число в формате строки.\n    Примеры:\n       truncate_number(string=618673000) == '618673'\n       truncate_number(string=7819765) == '7819765'\n    \"\"\"",
            "tests": "[{'string': '618673000'}, {'string': '7819765'}, {'string': '915760'}, {'string': '946843000'}, {'string': '661467'}, {'string': '76862550'}, {'string': '4754120'}, {'string': '11991000'}, {'string': '9796614'}, {'string': '33296700'}]"
        },
        "outputs": [
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ],
        "meta": {
            "id": 129,
            "canonical_solution": "",
            "entry_point": "truncate_number"
        }
    },
    "59": {
        "instruction": "Дан шаблон функции(ий) с описанием работы этой функции в качестве условия задачи. Допишите программу\n{function}",
        "inputs": {
            "function": "def make_binary(number: int) -> int:\n    \"\"\"Вам дано положительное число number в десятичной системе исчисления. Выведите данное число в двоичной системе исчисления.\n    Примеры:\n       make_binary(number=2) == 10\n       make_binary(number=28) == 11100\n    \"\"\"",
            "tests": "[{'number': 2}, {'number': 28}, {'number': 400}, {'number': 1234}, {'number': 3568}, {'number': 8765}, {'number': 13}, {'number': 927}, {'number': 1200}, {'number': 1000}]"
        },
        "outputs": [
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ],
        "meta": {
            "id": 59,
            "canonical_solution": "",
            "entry_point": "make_binary"
        }
    },
    "55": {
        "instruction": "Дано описание функции, напиши программу на языке Python\n{function}",
        "inputs": {
            "function": "from typing import List\n\n\ndef split_digits(array: List[int]) -> int:\n    \"\"\"Дан непустой список чисел array. Отделите все цифры, чтобы получился список всех цифр данного массива и выведите длину данного списка.\n    Примеры:\n       split_digits(array=[96, 12, 17, 15, 2, 43, 13, 39, 60, 73, 89, 70]) == 23\n       split_digits(array=[41, 50, 20, 70, 88, 12, 70]) == 14\n    \"\"\"",
            "tests": "[{'array': [96, 12, 17, 15, 2, 43, 13, 39, 60, 73, 89, 70]}, {'array': [41, 50, 20, 70, 88, 12, 70]}, {'array': [15, 10, 74, 10, 89, 36, 18, 5, 56, 67]}, {'array': [43, 18, 75, 41, 1, 86, 30, 43, 62, 30, 93]}, {'array': [15, 99, 51, 82, 15, 69]}, {'array': [84, 35, 25, 49, 95, 58, 57, 57, 38, 71, 60, 41]}, {'array': [43, 40, 58, 10, 64]}, {'array': [73, 60, 76, 2, 91, 99, 44, 4, 97]}, {'array': [60, 73, 43, 16, 89, 22, 3, 89, 27]}, {'array': [62, 30, 20, 74, 23, 29, 16, 93, 12, 21, 94, 80, 38]}]"
        },
        "outputs": [
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ],
        "meta": {
            "id": 55,
            "canonical_solution": "",
            "entry_point": "split_digits"
        }
    },
    "23": {
        "instruction": "Необходимо реализовать логику на языке Python для следующей программы\n{function}",
        "inputs": {
            "function": "def sparse_string(string: str, symbol: str) -> str:\n    \"\"\"Выведите исходную строку string, вставив между всеми ее символами специальный символ symbol.\n    Примеры:\n       sparse_string(string=ddd, symbol=) == 'ddd'\n       sparse_string(string=Мало теН половин , symbol= ) == 'М а л о   т е Н   п о л о в и н   '\n    \"\"\"",
            "tests": "[{'string': 'ddd', 'symbol': ''}, {'string': 'Мало теН половин ', 'symbol': ' '}, {'string': 'Мал0половин', 'symbol': '\\xa0'}, {'string': '\\nНет\\t', 'symbol': '\\r'}, {'string': 'Аргентина манит, кого бы вы думали?', 'symbol': '🙏'}, {'string': 'Добро поржаловать `\\xa0в\\xa0` Жи', 'symbol': '\\xa0'}, {'string': 'Вот это поворот!', 'symbol': '*'}, {'string': 'Следи за cобой будь оcторожен', 'symbol': '|'}, {'string': 'Мёрзни-мёрзни, волчий хвост!', 'symbol': '\\u200b'}, {'string': '\"И городу дорог огород у дороги\"', 'symbol': '\"'}]"
        },
        "outputs": [
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ],
        "meta": {
            "id": 23,
            "canonical_solution": "",
            "entry_point": "sparse_string"
        }
    },
    "7": {
        "instruction": "По данному условию с фиксированной шапкой функции(ий) напиши программу\n{function}",
        "inputs": {
            "function": "def split_wood(length: int, width: int, number: int) -> str:\n    \"\"\"Определите, можно ли отделить от шахматной доски размером length на width ровно number прямоугольников в одно действие. Отделять прямоугольники можно только по прямой линии (разрезать на две части по прямой). Например, нельзя разрезать квадраты шахматной доски по диагонали. Если да, выведите \"Да\", иначе – \"Нет\".\n    Примеры:\n       split_wood(length=3, width=3, number=2) == 'Нет'\n       split_wood(length=50, width=1, number=3) == 'Да'\n    \"\"\"",
            "tests": "[{'length': 3, 'width': 3, 'number': 2}, {'length': 50, 'width': 1, 'number': 3}, {'length': 1, 'width': 23, 'number': 1}, {'length': 33, 'width': 66, 'number': 222}, {'length': 22, 'width': 13, 'number': 3}, {'length': 2, 'width': 3, 'number': 5}, {'length': 2, 'width': 3, 'number': 2}, {'length': 3, 'width': 5, 'number': 7}, {'length': 2, 'width': 1, 'number': 5}, {'length': 3003, 'width': 505, 'number': 1010}]"
        },
        "outputs": [
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ],
        "meta": {
            "id": 7,
            "canonical_solution": "",
            "entry_point": "split_wood"
        }
    },
    "8": {
        "instruction": "Необходимо написать код по условию из строковой переменной документации, следующей после функции(ий)\n{function}",
        "inputs": {
            "function": "def is_acute(lengthA: int, lengthB: int, lengthC: int) -> str:\n    \"\"\"Определите на основании длин трех сторон треугольника: lengthA, lengthB, lengthC, является ли данный треугольник остроугольным. Треугольник является остроугольным, если сумма квадратов длин его двух сторон меньше квадрата третьей стороны для любой из сторон. Выведите \"Да\", если является, и \"Нет\", если не является.\n    Примеры:\n       is_acute(lengthA=3, lengthB=3, lengthC=2) == 'Да'\n       is_acute(lengthA=50, lengthB=1, lengthC=3) == 'Нет'\n    \"\"\"",
            "tests": "[{'lengthA': 3, 'lengthB': 3, 'lengthC': 2}, {'lengthA': 50, 'lengthB': 1, 'lengthC': 3}, {'lengthA': 1, 'lengthB': 23, 'lengthC': 1}, {'lengthA': 33, 'lengthB': 66, 'lengthC': 222}, {'lengthA': 22, 'lengthB': 20, 'lengthC': 12}, {'lengthA': 2, 'lengthB': 3, 'lengthC': 5}, {'lengthA': 2, 'lengthB': 3, 'lengthC': 2}, {'lengthA': 3, 'lengthB': 5, 'lengthC': 7}, {'lengthA': 10, 'lengthB': 6, 'lengthC': 9}, {'lengthA': 300, 'lengthB': 505, 'lengthC': 610}]"
        },
        "outputs": [
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ],
        "meta": {
            "id": 8,
            "canonical_solution": "",
            "entry_point": "is_acute"
        }
    },
    "108": {
        "instruction": "Необходимо написать код по условию из строковой переменной документации, следующей после функции(ий)\n{function}",
        "inputs": {
            "function": "def merge_strings(string1: str, string2: str) -> str:\n    \"\"\"Соедините две строки string1 и string2 так, чтобы попеременно сначала шел символ из первой строки, затем символ из второй строки в их изначальном порядке. Если одна из строк закончится, то добавьте все оставшиеся символы другой строки в конец новой строки. Выведите получившуюся строку.\n    Примеры:\n       merge_strings(string1=3ащёи, string2=ьчбрйёу7е) == '3ьачщбёрийёу7е'\n       merge_strings(string1=мёл, string2=эни) == 'мэёнли'\n    \"\"\"",
            "tests": "[{'string1': '3ащёи', 'string2': 'ьчбрйёу7е'}, {'string1': 'мёл', 'string2': 'эни'}, {'string1': 'е0э1тъ2ом', 'string2': '7ъушъеаь'}, {'string1': 'фш', 'string2': '6чн'}, {'string1': 'афжч', 'string2': '1щкаю5в1'}, {'string1': 'дфь', 'string2': '91ёх4ф'}, {'string1': 'х3гк', 'string2': 'гещсннвх'}, {'string1': 'эоэцявп', 'string2': 'шшвп8ц'}, {'string1': 'вн7шц8э', 'string2': 'лахдщ'}, {'string1': 'цх', 'string2': 'ещты6нм53'}]"
        },
        "outputs": [
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ],
        "meta": {
            "id": 108,
            "canonical_solution": "",
            "entry_point": "merge_strings"
        }
    },
    "151": {
        "instruction": "Реализуй функцию(ии) на языке Python\n{function}",
        "inputs": {
            "function": "def maximum_swap(number: int) -> int:\n    \"\"\"Выведите максимально возможное число, которое можно получить перестановкой любых двух цифр в числе number. Если в числе только одна цифра, то ответом будет само это число.\n    Примеры:\n       maximum_swap(number=1) == 1\n       maximum_swap(number=192) == 912\n    \"\"\"",
            "tests": "[{'number': 1}, {'number': 192}, {'number': 843}, {'number': 1230}, {'number': 49}, {'number': 8763}, {'number': 8}, {'number': 219}, {'number': 288}, {'number': 4979}]"
        },
        "outputs": [
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ],
        "meta": {
            "id": 151,
            "canonical_solution": "",
            "entry_point": "maximum_swap"
        }
    },
    "22": {
        "instruction": "Напишите программу по строке документации\n{function}",
        "inputs": {
            "function": "def solve_system(A: int, B: int, C: int, D: int, E: int, F: int) -> str:\n    \"\"\"По данным коэффициентам A, B, C, D, E, F определите, имеет ли решения система из двух линейных уравнений: (1) Ax + By = E, (2) Cx + Dy = F. Коэффициенты всегда являются целыми числами. Если система с данными значениями коэффициентов имеет решения, выведите \"Да\", иначе выведите \"Нет\".\n    Примеры:\n       solve_system(A=3, B=-3, C=0, D=0, E=0, F=2000) == 'Нет'\n       solve_system(A=0, B=-1, C=3, D=2, E=12, F=2) == 'Да'\n    \"\"\"",
            "tests": "[{'A': 3, 'B': -3, 'C': 0, 'D': 0, 'E': 0, 'F': 2000}, {'A': 0, 'B': -1, 'C': 3, 'D': 2, 'E': 12, 'F': 2}, {'A': 1, 'B': 20, 'C': 20, 'D': 400, 'E': 1, 'F': 404}, {'A': -33, 'B': 66, 'C': 222, 'D': 1000, 'E': 99, 'F': 1001}, {'A': 0, 'B': 0, 'C': 3, 'D': 15000, 'E': 88, 'F': 20000}, {'A': 2, 'B': 3, 'C': 5, 'D': 1, 'E': 98, 'F': 2}, {'A': -3, 'B': -3, 'C': 1, 'D': 200, 'E': 55, 'F': 300}, {'A': 3, 'B': 5, 'C': 7, 'D': 1000, 'E': 99, 'F': 1001}, {'A': 0, 'B': 0, 'C': 0, 'D': 0, 'E': 0, 'F': 0}, {'A': -3003, 'B': 505, 'C': 222, 'D': 30, 'E': 60, 'F': 199}]"
        },
        "outputs": [
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ],
        "meta": {
            "id": 22,
            "canonical_solution": "",
            "entry_point": "solve_system"
        }
    },
    "139": {
        "instruction": "Дан шаблон функции(ий) с описанием работы этой функции в качестве условия задачи. Допишите программу\n{function}",
        "inputs": {
            "function": "from typing import List\n\n\ndef matrix_truncation(matrix: List[List[int]]) -> int:\n    \"\"\"В целочисленной матрице matrix итеративно удалите из каждой строки наибольший элемент, а затем прибавьте к ответу максимум из удаленных элементов. Какое число получится после удаления всех элементов матрицы? Выведите полученное число.\n    Примеры:\n       matrix_truncation(matrix=[[6, 10, 5, 1, 4, 11, 11, 10], [9, 10, 10, 12, 4, 4, 1, 3], [5, 3, 10, 7, 14, 6, 14, 11], [4, 0, 14, 8, 0, 7, 5, 11], [4, 2, 3, 10, 10, 4, 12, 13], [9, 7, 10, 2, 2, 0, 6, 7], [10, 14, 8, 12, 12, 3, 6, 12], [14, 7, 0, 8, 13, 13, 0, 1]]) == 80\n       matrix_truncation(matrix=[[6, 13, 1, 11, 12, 10, 8, 9, 3], [4, 14, 5, 1, 4, 10, 13, 2, 9], [2, 10, 12, 14, 3, 0, 11, 8, 12], [12, 9, 9, 9, 2, 9, 7, 2, 8], [4, 4, 0, 4, 11, 5, 10, 10, 4], [8, 4, 6, 14, 7, 4, 14, 9, 9], [5, 5, 10, 2, 13, 2, 13, 6, 3], [3, 13, 5, 5, 11, 11, 13, 10, 9], [6, 11, 7, 11, 9, 9, 14, 14, 7]]) == 90\n    \"\"\"",
            "tests": "[{'matrix': [[6, 10, 5, 1, 4, 11, 11, 10], [9, 10, 10, 12, 4, 4, 1, 3], [5, 3, 10, 7, 14, 6, 14, 11], [4, 0, 14, 8, 0, 7, 5, 11], [4, 2, 3, 10, 10, 4, 12, 13], [9, 7, 10, 2, 2, 0, 6, 7], [10, 14, 8, 12, 12, 3, 6, 12], [14, 7, 0, 8, 13, 13, 0, 1]]}, {'matrix': [[6, 13, 1, 11, 12, 10, 8, 9, 3], [4, 14, 5, 1, 4, 10, 13, 2, 9], [2, 10, 12, 14, 3, 0, 11, 8, 12], [12, 9, 9, 9, 2, 9, 7, 2, 8], [4, 4, 0, 4, 11, 5, 10, 10, 4], [8, 4, 6, 14, 7, 4, 14, 9, 9], [5, 5, 10, 2, 13, 2, 13, 6, 3], [3, 13, 5, 5, 11, 11, 13, 10, 9], [6, 11, 7, 11, 9, 9, 14, 14, 7]]}, {'matrix': [[11, 7, 4, 4, 6, 12, 8, 9, 8, 13], [11, 5, 3, 13, 9, 9, 5, 7, 1, 10], [14, 10, 7, 4, 8, 3, 7, 6, 5, 2], [2, 13, 8, 12, 4, 5, 10, 10, 14, 4], [13, 2, 11, 7, 6, 6, 8, 8, 4, 11], [1, 1, 3, 11, 4, 12, 11, 6, 3, 5], [8, 0, 4, 5, 14, 5, 11, 14, 12, 10], [2, 4, 8, 1, 11, 6, 4, 12, 5, 3], [6, 1, 14, 14, 2, 1, 7, 10, 11, 5], [4, 7, 14, 4, 3, 12, 11, 3, 3, 5]]}, {'matrix': [[1, 10, 1, 1, 4, 9, 14, 6, 6, 0, 4], [11, 4, 9, 6, 8, 11, 3, 13, 6, 12, 2], [13, 6, 10, 14, 8, 8, 0, 12, 8, 10, 5], [5, 7, 0, 9, 13, 9, 1, 1, 5, 9, 13], [7, 10, 5, 11, 0, 6, 2, 9, 11, 9, 3], [2, 8, 12, 5, 2, 8, 1, 5, 11, 8, 3], [11, 1, 7, 2, 1, 5, 12, 0, 12, 12, 6], [14, 13, 13, 9, 5, 4, 2, 13, 4, 5, 2], [9, 4, 1, 3, 10, 5, 7, 0, 1, 4, 10], [3, 6, 8, 6, 14, 6, 12, 8, 9, 13, 6], [7, 1, 4, 0, 10, 13, 11, 13, 9, 4, 7]]}, {'matrix': [[7, 12, 10, 9, 8, 10], [10, 3, 8, 3, 8, 1], [1, 7, 2, 11, 12, 0], [12, 9, 10, 14, 8, 0], [13, 13, 10, 0, 8, 2], [2, 5, 5, 8, 9, 2]]}, {'matrix': [[4, 5, 6, 2, 14, 10, 11], [5, 13, 3, 13, 11, 7, 2], [1, 5, 2, 3, 3, 14, 8], [1, 14, 2, 7, 14, 2, 7], [5, 3, 10, 14, 5, 13, 0], [7, 1, 6, 14, 7, 1, 12], [11, 0, 13, 4, 14, 8, 3]]}, {'matrix': [[11, 14, 2, 2, 1, 1, 7], [1, 14, 9, 9, 14, 6, 13], [5, 12, 9, 9, 10, 9, 0], [13, 11, 6, 0, 7, 14, 3], [11, 12, 14, 8, 7, 0, 9], [10, 11, 8, 11, 5, 0, 1], [1, 3, 8, 2, 9, 10, 2]]}, {'matrix': [[5, 9, 4, 0, 14, 12, 5, 5, 11, 8], [6, 5, 0, 9, 2, 2, 1, 0, 8, 6], [9, 9, 3, 8, 13, 3, 6, 1, 9, 5], [0, 4, 8, 10, 12, 1, 12, 11, 0, 10], [10, 11, 1, 3, 8, 9, 1, 0, 14, 9], [2, 8, 11, 6, 5, 5, 6, 13, 12, 1], [11, 1, 6, 7, 1, 7, 5, 13, 13, 12], [13, 0, 8, 3, 5, 13, 1, 13, 5, 14], [13, 14, 6, 3, 1, 7, 13, 2, 2, 6], [6, 8, 14, 13, 7, 5, 4, 12, 1, 7]]}, {'matrix': [[5, 14, 7, 6, 3, 2, 5, 4, 1, 9], [12, 11, 6, 6, 2, 10, 3, 8, 2, 3], [14, 12, 11, 7, 6, 5, 4, 8, 10, 0], [14, 10, 11, 14, 7, 11, 13, 11, 4, 3], [3, 10, 5, 6, 4, 8, 6, 6, 4, 10], [14, 2, 7, 1, 14, 6, 1, 12, 4, 5], [13, 9, 14, 3, 4, 14, 11, 3, 0, 1], [4, 12, 0, 14, 13, 6, 0, 12, 7, 14], [13, 6, 5, 8, 2, 13, 4, 11, 1, 0], [8, 5, 10, 6, 7, 12, 10, 6, 2, 12]]}, {'matrix': [[0, 3, 0, 8, 3, 10, 13, 4, 1, 4, 8], [1, 7, 4, 7, 12, 13, 13, 11, 0, 1, 14], [13, 3, 13, 5, 11, 9, 12, 3, 1, 0, 6], [1, 5, 2, 10, 4, 11, 12, 6, 8, 6, 7], [5, 2, 11, 13, 7, 9, 5, 6, 13, 10, 7], [8, 13, 11, 6, 4, 12, 10, 8, 2, 10, 14], [0, 12, 13, 6, 11, 10, 5, 8, 6, 4, 5], [13, 5, 6, 10, 2, 12, 3, 3, 3, 8, 0], [0, 8, 4, 4, 9, 9, 5, 4, 10, 7, 6], [3, 5, 9, 13, 5, 2, 1, 13, 8, 3, 2], [7, 7, 13, 10, 2, 3, 12, 9, 9, 12, 6]]}]"
        },
        "outputs": [
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ],
        "meta": {
            "id": 139,
            "canonical_solution": "",
            "entry_point": "matrix_truncation"
        }
    },
    "26": {
        "instruction": "На вход подается функция(ии) с описанием в виде строки docstring. В соответствии с описанием вам необходимо реализовать функцию(ии)\n{function}",
        "inputs": {
            "function": "def count_palindromes(first_number: int, last_number: int) -> int:\n    \"\"\"Выведите, сколько чисел между четырёхзначными числами first_number и last_number, включая их, являются палиндромами. Отрицательные числа не считаются палиндромами.\n    Примеры:\n       count_palindromes(first_number=3003, last_number=6006) == 31\n       count_palindromes(first_number=2500, last_number=2508) == -1\n    \"\"\"",
            "tests": "[{'first_number': 3003, 'last_number': 6006}, {'first_number': 2500, 'last_number': 2508}, {'first_number': -4708, 'last_number': 6006}, {'first_number': 2537, 'last_number': 2547}, {'first_number': 1000, 'last_number': 2000}, {'first_number': 2555, 'last_number': 6553}, {'first_number': 5447, 'last_number': 5574}, {'first_number': 1440, 'last_number': 4444}, {'first_number': -4444, 'last_number': 4444}, {'first_number': 4553, 'last_number': 2002}]"
        },
        "outputs": [
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ],
        "meta": {
            "id": 26,
            "canonical_solution": "",
            "entry_point": "count_palindromes"
        }
    },
    "35": {
        "instruction": "Дано описание функции, напиши программу на языке Python\n{function}",
        "inputs": {
            "function": "def extract_string(string: str, symbol: str) -> str:\n    \"\"\"Разверните в обратном порядке подстроку строки string, которая заключена между первым и последним вхождениями символа symbol в string. Остальные символы оригинальной строки должны остаться на своих изначальных местах. Если symbol встречается в string 1 или 0 раз, то выведите \"Нет\".\n    Примеры:\n       extract_string(string=, symbol=) == 'Нет'\n       extract_string(string=Мало теН половин , symbol= ) == 'Мало ниволоп Нет '\n    \"\"\"",
            "tests": "[{'string': '', 'symbol': ''}, {'string': 'Мало теН половин ', 'symbol': ' '}, {'string': 'Мало теН половин', 'symbol': ' '}, {'string': '\\rтеН\\r', 'symbol': '\\r'}, {'string': '🙏аргентинаманит🙏 кого бы вы думали?', 'symbol': '🙏'}, {'string': 'Добро поржаловать `\\xa0в\\xa0` Жи', 'symbol': '\\xa0'}, {'string': 'Вот это поворот!', 'symbol': '\\xa0'}, {'string': 'Следи за cобой будь оcторожен', 'symbol': 'c'}, {'string': 'Мёрзни-\\u200bмёрзни, волчий хвост!', 'symbol': ','}, {'string': '\"И городу дорог огород у дороги\"', 'symbol': '\"'}]"
        },
        "outputs": [
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ],
        "meta": {
            "id": 35,
            "canonical_solution": "",
            "entry_point": "extract_string"
        }
    },
    "57": {
        "instruction": "По данному условию с фиксированной шапкой функции(ий) напиши программу\n{function}",
        "inputs": {
            "function": "def russian_round(number: float) -> int:\n    \"\"\"Округлите число number по российским правилам: если дробная часть числа равна или больше 0.5, то число округляется вверх, иначе – вниз. Выведите полученное число.\n    Примеры:\n       russian_round(number=19.51035) == 20\n       russian_round(number=13.53934) == 14\n    \"\"\"",
            "tests": "[{'number': 19.51035}, {'number': 13.53934}, {'number': 17.55757}, {'number': 1.43237}, {'number': 11.67251}, {'number': 11.59171}, {'number': 16.24636}, {'number': 16.26078}, {'number': 12.24728}, {'number': 2.04019}]"
        },
        "outputs": [
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ],
        "meta": {
            "id": 57,
            "canonical_solution": "",
            "entry_point": "russian_round"
        }
    },
    "62": {
        "instruction": "Напишите программу по строке документации\n{function}",
        "inputs": {
            "function": "def is_ugly(number: int) -> str:\n    \"\"\"Определите, является ли число number некрасивым. Некрасивое число – это такое число, которое делится только на 2, 3 и 5 (необязательно все сразу) без остатка. Если число некрасивое, выведите \"Да\", иначе выведите \"Нет\".\n    Примеры:\n       is_ugly(number=45) == 'Да'\n       is_ugly(number=44) == 'Нет'\n    \"\"\"",
            "tests": "[{'number': 45}, {'number': 44}, {'number': 21}, {'number': 83}, {'number': 70}, {'number': 19}, {'number': 9}, {'number': 80}, {'number': 50}, {'number': 65}]"
        },
        "outputs": [
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ],
        "meta": {
            "id": 62,
            "canonical_solution": "",
            "entry_point": "is_ugly"
        }
    },
    "70": {
        "instruction": "Реши задачу по программированию\n{function}",
        "inputs": {
            "function": "def bit_inversion(number: int) -> int:\n    \"\"\"Дано целое положительное число number. Инвертируйте все биты в двоичной записи данного числа. Выведите получившееся число в десятичной системе исчисления.\n    Примеры:\n       bit_inversion(number=2) == 1\n       bit_inversion(number=28) == 3\n    \"\"\"",
            "tests": "[{'number': 2}, {'number': 28}, {'number': 387}, {'number': 1234}, {'number': 3568}, {'number': 876543}, {'number': 6}, {'number': 496}, {'number': 8128}, {'number': 98376}]"
        },
        "outputs": [
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ],
        "meta": {
            "id": 70,
            "canonical_solution": "",
            "entry_point": "bit_inversion"
        }
    },
    "6": {
        "instruction": "На вход подается функция(ии) с описанием в виде строки docstring. В соответствии с описанием вам необходимо реализовать функцию(ии)\n{function}",
        "inputs": {
            "function": "def same_entrance(first_number: int, second_number: int) -> str:\n    \"\"\"Определите, могут ли квартиры с номерами first_number и second_number быть первой и последней квартирой в одном подъезде дома? В доме больше одного подъезда, в каждом подъезде всегда одинаковое количество квартир. Нумерация квартир начинается с единицы. Если могут, выведите \"Да\", иначе – \"Нет\".\n    Примеры:\n       same_entrance(first_number=33, second_number=3) == 'Нет'\n       same_entrance(first_number=25, second_number=2) == 'Нет'\n    \"\"\"",
            "tests": "[{'first_number': 33, 'second_number': 3}, {'first_number': 25, 'second_number': 2}, {'first_number': 4, 'second_number': 6}, {'first_number': 253, 'second_number': 254}, {'first_number': 1, 'second_number': 2}, {'first_number': 255, 'second_number': 65535}, {'first_number': 54475474574, 'second_number': 9876342156547}, {'first_number': 144, 'second_number': 4}, {'first_number': 44, 'second_number': 44}, {'first_number': 45, 'second_number': 22}]"
        },
        "outputs": [
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ],
        "meta": {
            "id": 6,
            "canonical_solution": "",
            "entry_point": "same_entrance"
        }
    },
    "28": {
        "instruction": "Необходимо написать код по условию из строковой переменной документации, следующей после функции(ий)\n{function}",
        "inputs": {
            "function": "from typing import List\n\n\ndef count_pairs(array: List[int]) -> int:\n    \"\"\"Сколько в массиве array пар одинаковых элементов? Любые два одинаковых по значению элемента array с разными индексами образуют пару, каждый элемент может входить только в одну пару. Выведите количество пар.\n    Примеры:\n       count_pairs(array=[1, 5, 5, 6, 3, 2, 3, 9, 6, 3, 8, 6, 3, 9]) == 11\n       count_pairs(array=[7, 6, 6, 2, 1, 7, 8, 8, 3, 6]) == 5\n    \"\"\"",
            "tests": "[{'array': [1, 5, 5, 6, 3, 2, 3, 9, 6, 3, 8, 6, 3, 9]}, {'array': [7, 6, 6, 2, 1, 7, 8, 8, 3, 6]}, {'array': [4, 1, 1, 7, 8]}, {'array': [5, 6, 8, 3, 7, 3, 4, 7, 3]}, {'array': [9, 8, 2, 3, 7, 8, 7]}, {'array': [2, 7, 0, 8, 1, 7, 4, 8]}, {'array': [6, 4, 2, 6, 9, 7, 5, 5, 5, 8, 0, 8, 0, 3]}, {'array': [1, 2, 4, 5, 3, 2, 1, 1, 0, 9, 3, 6, 8, 9]}, {'array': [3, 5, 0, 9, 7, 0, 8, 2, 0, 1, 6, 8, 2]}, {'array': [4, 7, 2, 3, 4, 4, 9, 8, 1, 7, 7]}]"
        },
        "outputs": [
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ],
        "meta": {
            "id": 28,
            "canonical_solution": "",
            "entry_point": "count_pairs"
        }
    },
    "163": {
        "instruction": "Необходимо реализовать логику на языке Python для следующей программы\n{function}",
        "inputs": {
            "function": "from typing import List\n\n\ndef absolute_difference(array: List[int]) -> List[int]:\n    \"\"\"Дан список целых чисел array. Абсолютная разность числа и массива определяется, как сумма абсолютных значений разностей данного числа и всех элементов массива. Постройте и выведите новый список, в котором каждый элемент равен абсолютной разности элемента с тем же индексом в array и списка array.\n    Примеры:\n       absolute_difference(array=[51, -68, -92, -23, -56, 79, -40, 9, 36, -63]) == [-677, 275, 419, 143, 209, 209, -29, 167, 329, -463]\n       absolute_difference(array=[-36, 62, -66, -51, -5, 34, 2, -67, -52, 41, 91, -9]) == [376, -604, 420, 330, 146, 68, 68, -70, -10, 548, 948, -52]\n    \"\"\"",
            "tests": "[{'array': [51, -68, -92, -23, -56, 79, -40, 9, 36, -63]}, {'array': [-36, 62, -66, -51, -5, 34, 2, -67, -52, 41, 91, -9]}, {'array': [86, -1, -61, 89, 50, -13, -77, 35, 41, -16]}, {'array': [16, 9, 57, 29, -15, 22, -59, 44, 40, 18, -21, -86]}, {'array': [-47, 74, -12, 17, 14, 4, 73, -26, -33, 60]}, {'array': [-2, -76, 68, 20, 84, 99, -29, 89, -73, 57, -77, -54]}, {'array': [-81, -44, -64, 24, 57, 76, -64, -26, 91, 96, 66, 84]}, {'array': [-52, 75, 22, -8, 89, 18, 62, -57, -62, 39, 2, -95]}, {'array': [19, 3, 3, -11, 10, 19, -69, -60, -90, 22, 74, -81, 98, -63]}, {'array': [-32, -73, -21, 81, 61, -15, -97, -43, -15, -71, 18, 18, -99, -4]}]"
        },
        "outputs": [
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            "",
            ""
        ],
        "meta": {
            "id": 163,
            "canonical_solution": "",
            "entry_point": "absolute_difference"
        }
    }
}